{"meta":{"title":"Mandy's Blog","subtitle":"","description":"","author":"Mandy","url":"https://mandylucky.github.io","root":"/"},"pages":[{"title":"404 Not Found：该页无法显示","date":"2023-06-27T03:33:17.753Z","updated":"2023-06-27T03:33:17.753Z","comments":false,"path":"/404.html","permalink":"https://mandylucky.github.io/404.html","excerpt":"","text":""},{"title":"关于","date":"2023-06-27T03:33:17.756Z","updated":"2023-06-27T03:33:17.756Z","comments":false,"path":"about/index.html","permalink":"https://mandylucky.github.io/about/index.html","excerpt":"","text":"个人详细介绍"},{"title":"分类","date":"2023-06-27T03:33:17.756Z","updated":"2023-06-27T03:33:17.756Z","comments":false,"path":"categories/index.html","permalink":"https://mandylucky.github.io/categories/index.html","excerpt":"","text":""},{"title":"Repositories","date":"2023-06-27T03:33:17.756Z","updated":"2023-06-27T03:33:17.756Z","comments":false,"path":"repository/index.html","permalink":"https://mandylucky.github.io/repository/index.html","excerpt":"","text":""},{"title":"书单","date":"2023-06-27T03:33:17.756Z","updated":"2023-06-27T03:33:17.756Z","comments":false,"path":"books/index.html","permalink":"https://mandylucky.github.io/books/index.html","excerpt":"","text":""},{"title":"友情链接","date":"2023-06-27T03:33:17.756Z","updated":"2023-06-27T03:33:17.756Z","comments":true,"path":"links/index.html","permalink":"https://mandylucky.github.io/links/index.html","excerpt":"","text":""},{"title":"标签","date":"2023-06-27T03:33:17.756Z","updated":"2023-06-27T03:33:17.756Z","comments":false,"path":"tags/index.html","permalink":"https://mandylucky.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"vue最佳实践","slug":"js/vue/vue最佳实践","date":"2023-06-27T06:50:49.000Z","updated":"2023-06-27T07:33:43.415Z","comments":true,"path":"2023/06/27/js/vue/vue最佳实践/","link":"","permalink":"https://mandylucky.github.io/2023/06/27/js/vue/vue%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/","excerpt":"","text":"一、设置属性keykey属性主要用于虚拟dom的算法中，在对比新旧虚拟DOM时 辨识虚拟DOM，加快查找速度。 使用场景：1）v-for 渲染列表2）v-if/v-if-else/v-else 元素类型相同时 （删除后新增 vs 就地修改） 二、路由切换组件不变现象：/detail/1 切换到 /detail/2时，组件的声明周期钩子不会重新触发 原因：vue-router识别出两个路由是使用同一个组件，从而进行复用，并不会重新创建组件，因此生命周期钩子不会被触发 解决方案：（1）路由导航守卫beforeRouteUpdate （优）该守卫在当前路由改变且组件被复用时调用，所以可以在组件内定义路由导航守卫来解决这个问题 （2）观察$route 对象的变化 12345watch:&#123; &#x27;$route&#x27;(to,from)&#123; // 对路由变化作出响应 &#125;&#125; 缺点：组件内多一个watch，会带来依赖追踪的内存开销如果最终选择使用watch 解决这个问题，推荐只观察自己需要的query,来减少不必要的请求 12345watch:&#123; &#x27;$route.query.id&#x27;()&#123; &#125;&#125; （3）为router-view 组件添加属性key不推荐，设置key 每次切换路由都会先销毁组件再创建新组件，造成性能浪费。 揭秘 Vue.js 九个性能优化技巧","categories":[{"name":"Vue","slug":"Vue","permalink":"https://mandylucky.github.io/categories/Vue/"}],"tags":[{"name":"最佳实践","slug":"最佳实践","permalink":"https://mandylucky.github.io/tags/%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/"}]},{"title":"promise","slug":"js/es6/promise","date":"2021-05-20T23:43:56.000Z","updated":"2023-06-27T03:33:17.754Z","comments":true,"path":"2021/05/21/js/es6/promise/","link":"","permalink":"https://mandylucky.github.io/2021/05/21/js/es6/promise/","excerpt":"","text":"使用例子 12345678910111213const promise = new Promise(function(resolve, reject) &#123; if (/* 异步操作成功 */)&#123; resolve(value); &#125; else &#123; reject(error); &#125;&#125;);promise.then(function(value) &#123; // success&#125;, function(error) &#123; // failure&#125;); 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113const PENDING=&#x27;PENDING&#x27;const REJECTED=&#x27;REJECTED&#x27;const FULFILLED=&#x27;FULFILLED&#x27;class MyPromise&#123; // constructor:初始化数据，调用传入函数 constructor(handler)&#123; if(typeof handler !==&#x27;function&#x27;)&#123; throw new Error(&#x27;handler not a func &#x27;) &#125; this._status=PENDING; this._value=undefined; this._fullfillQueue=[]; this._rejectQueue=[]; try&#123; handler(this._resolve.bind(this),this._reject.bind(this)) &#125;catch(err)&#123; this._reject(err) &#125; &#125; // _resolve:只有状态为pending 时才执行，修改状态、修改值、执行并清空_fullfillQueue、_rejectQueue中函数。 另外要判断value 是不是promise 实例做不同处理 _resolve(value)&#123; if(this._status !==PENDING) return; const runFulfilled=(value)=&gt;&#123; let cb; while(cb=this._fullfillQueue.shift())&#123; cb(value) &#125; &#125; const runRejected=(value)=&gt;&#123; let cb; while(cb=this._rejectQueue.shift())&#123; cb(value) &#125; &#125; if(value instanceof MyPromise)&#123; value.then(res=&gt;&#123; this.value=res; this._status=FULFILLED; runFulfilled(res) &#125;,err=&gt;&#123; this.value=err; this._status=REJECTED; runRejected(err) &#125;) &#125;else&#123; this.value=value; this._status=FULFILLED; runFulfilled(value) &#125; &#125; // _reject:只有状态为pending 时才执行，修改状态、修改值、执行并清空_rejectQueue中函数。 _reject(err)&#123; if(this._status !==PENDING) return this._status=REJECTED this._value=err; let cb; while(cb=this._rejectQueue.shift())&#123; cb(err) &#125; &#125; // 返回promise实例,将then中传入得成功失败回调进行封装，根据当前状态直接执行或者加入队列 then(onFulfilled,onRejected)&#123; const &#123;_value,_status&#125;=this; return new MyPromise((onNextFulfilled,onNextRejected)=&gt;&#123; const runFulfill=(value)=&gt;&#123; try&#123; if(typeof onFulfilled !==&quot;function&quot;)&#123; onNextFulfilled(value) &#125;else&#123; let res=onFulfilled(value); if(res instanceof MyPromise)&#123; res.then(onNextFulfilled,onNextRejected) &#125;else&#123; onNextFulfilled(res) &#125; &#125; &#125;catch(err)&#123; onNextRejected(err) &#125; &#125; const runReject=(error)=&gt;&#123; try&#123; if(typeof onRejected !== &#x27;function&#x27;)&#123; onNextRejected(error) &#125;else&#123; let res=onRejected(error) if(res instanceof MyPromise)&#123; res.then(onNextFulfilled,onNextRejected) &#125;else&#123; onNextFulfilled(res) &#125; &#125; &#125;catch(err)&#123; onNextRejected(err) &#125; &#125; switch(_status)&#123; case PENDING: this._fullfillQueue.push(runFulfill) this._rejectQueue.push(runReject) break; case FULFILLED: runFulfill(_value) break; case REJECTED: runReject(_value) &#125; &#125;) &#125;&#125;","categories":[{"name":"js","slug":"js","permalink":"https://mandylucky.github.io/categories/js/"}],"tags":[{"name":"ES6","slug":"ES6","permalink":"https://mandylucky.github.io/tags/ES6/"}]},{"title":"CORS","slug":"浏览器/CORS","date":"2021-05-17T23:38:13.000Z","updated":"2023-06-27T03:33:17.755Z","comments":true,"path":"2021/05/18/浏览器/CORS/","link":"","permalink":"https://mandylucky.github.io/2021/05/18/%E6%B5%8F%E8%A7%88%E5%99%A8/CORS/","excerpt":"","text":"简介CORS是一个W3C标准，全称是”跨域资源共享”（Cross-origin resource sharing）。 它允许浏览器向跨源服务器，发出XMLHttpRequest请求，从而克服了AJAX只能同源使用的限制。 CORS需要浏览器和服务器同时支持。目前，所有浏览器都支持该功能，IE浏览器不能低于IE10。 整个CORS通信过程，都是浏览器自动完成，不需要用户参与。对于开发者来说，CORS通信与同源的AJAX通信没有差别，代码完全一样。浏览器一旦发现AJAX请求跨源，就会自动添加一些附加的头信息，有时还会多出一次附加的请求，但用户不会有感觉。 因此，实现CORS通信的关键是服务器。只要服务器实现了CORS接口，就可以跨源通信。 两种请求浏览器将CORS请求分成两类：简单请求（simple request）和非简单请求（not-so-simple request）。 只要同时满足以下两大条件，就属于简单请求(1) 请求方法是以下三种方法之一： HEAD GET POST (2) HTTP的头信息不超出以下几种字段： Accept Accept-Language Content-Language Last-Event-ID Content-Type：只限于三个值application/x-www-form-urlencoded、multipart/form-data、text/plain 简单请求的基本流程浏览器发现这次跨源AJAX请求是简单请求，就自动在头信息之中，添加一个Origin字段。 如果Origin指定的源，不在许可范围内，服务器会返回一个正常的HTTP回应。浏览器发现，这个回应的头信息没有包含Access-Control-Allow-Origin字段，就知道出错了，从而抛出一个错误，被XMLHttpRequest的onerror回调函数捕获。【这种错误无法通过状态码识别,HTTP回应的状态码有可能是200】 如果Origin指定的域名在许可范围内，服务器返回的响应，会多出几个头信息字段。以Access-Control-开头 Access-Control-Allow-Origin该字段是必须的。它的值要么是请求时Origin字段的值，要么是一个*，表示接受任意域名的请求。 Access-Control-Allow-Credentials该字段可选。它的值是一个布尔值，表示是否允许发送Cookie。 Access-Control-Expose-Headers默认只能拿到6个基本字段，如果想拿到其他字段，就必须在Access-Control-Expose-Headers 里面指定 withCredentials 属性上面说到，CORS请求默认不发送Cookie和HTTP认证信息。如果要把Cookie发到服务器，一方面要服务器同意，指定Access-Control-Allow-Credentials字段。另一方面，开发者必须在AJAX请求中打开withCredentials属性。 需要注意的是，如果要发送Cookie，Access-Control-Allow-Origin就不能设为星号，必须指定明确的、与请求网页一致的域名。 非简单请求 预检请求非简单请求的CORS请求，会在正式通信之前，增加一次HTTP查询请求，称为”预检”请求 浏览器先询问服务器，当前网页所在的域名是否在服务器的许可名单之中，以及可以使用哪些HTTP动词和头信息字段。只有得到肯定答复，浏览器才会发出正式的XMLHttpRequest请求，否则就报错。 “预检”请求用的请求方法是OPTIONS，表示这个请求是用来询问的。 Access-Control-Request-Method该字段是必须的，用来列出浏览器的CORS请求会用到哪些HTTP方法 Access-Control-Request-Headers该字段是一个逗号分隔的字符串，指定浏览器CORS请求会额外发送的头信息字段 预检请求的回应服务器收到”预检”请求以后，检查了Origin、Access-Control-Request-Method和Access-Control-Request-Headers字段以后，确认允许跨源请求，就可以做出回应。 返回 Access-Control-Allow-Origin 表示同意任意跨源请求 Access-Control-Allow-Methods 该字段必需，表明服务器支持的所有跨域请求的方法，这是为了避免多次”预检”请求。 Access-Control-Allow-Headers如果浏览器请求包括Access-Control-Request-Headers字段，则Access-Control-Allow-Headers字段是必需的。不限于浏览器在”预检”中请求的字段。 Access-Control-Allow-Credentials允许发送cookie Access-Control-Max-Age该字段可选，用来指定本次预检请求的有效期，单位为秒。在有效期内，不用发出另一条预检请求。 浏览器的正常请求和回应一旦服务器通过了”预检”请求，以后每次浏览器正常的CORS请求，就都跟简单请求一样，会有一个Origin头信息字段。服务器的回应，也都会有一个Access-Control-Allow-Origin头信息字段。 与JSONP比较CORS与JSONP的使用目的相同，但是比JSONP更强大。 JSONP只支持GET请求，CORS支持所有类型的HTTP请求。JSONP的优势在于支持老式浏览器，以及可以向不支持CORS的网站请求数据。 总结 CORS 请求分成两类：简单请求、非简单请求 简单请求请求头：origin响应头：Access-Control-Allow-Origin 、Access-Control-Allow-Credentials(可选) 、 Access-Control-Allow-Expose-Header (可选) 发送cookie服务端要指定 Access-Control-Allow-Credentials字段。开发者在AJAX请求中打开withCredentials 属性 非简单请求 预检要发送预检请求，请求头：Origin、Access-Control-Request-Method、Access-Control-Request-Headers（可选） 服务器收到预检请求，检查后 确认允许跨域请求会作出响应 响应头：Access-Control-Allow-Origin 、Access-Control-Allow-Methods、Access-Control-Allow-Headers（可选）、Access-Control-Allow-Credentials（可选）、Access-Control-Max-Age 用于指定本次预检请求的有效期（可选） 非简单请求 正常请求和回应通过预检请求后，和简单请求一样会有一个Origin请求头，Access-Control-Allow-Origin 响应头 JSONP 只支持get 请求，但兼容老浏览器。CORS支持所有类型的http请求 跨域资源共享 CORS 详解","categories":[{"name":"浏览器","slug":"浏览器","permalink":"https://mandylucky.github.io/categories/%E6%B5%8F%E8%A7%88%E5%99%A8/"}],"tags":[{"name":"CORS","slug":"CORS","permalink":"https://mandylucky.github.io/tags/CORS/"}]},{"title":"浏览器存储","slug":"浏览器/浏览器存储","date":"2021-05-17T14:08:22.000Z","updated":"2023-06-27T03:33:17.755Z","comments":true,"path":"2021/05/17/浏览器/浏览器存储/","link":"","permalink":"https://mandylucky.github.io/2021/05/17/%E6%B5%8F%E8%A7%88%E5%99%A8/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%AD%98%E5%82%A8/","excerpt":"","text":"存储方式：Cookie、WebStorage、IndexDB Cookiehttps://developer.mozilla.org/zh-CN/docs/Web/HTTP/Cookies WebStoragelocalStorage、sessionStorage 是 Storage 的实例特点：以同步阻塞的方式写入、大小限制：&lt;5MB、只能存字符串、受同源策略限制 方法 Storage.key(): 该方法接受一个数值 n 作为参数，并返回存储中的第 n 个键名。 Storage.getItem(): 该方法接受一个键名作为参数，返回键名对应的值。 Storage.setItem():该方法接受一个键名和值作为参数，将会把键值对添加到存储中，如果键名存在，则更新其对应的值。 Storage.removeItem():该方法接受一个键名作为参数，并把该键名从存储中删除 Storage.clear():调用该方法会清空存储中的所有键名。 localStorage(永久储存机制) 永久缓存，数据保存到浏览器清除缓存/ js主动删除 sessionStorage(会话存储机制) 只在会话期间有效，关闭浏览器时清除IndexDBIndexedDB 就是浏览器提供的本地数据库，IndexedDB 允许储存大量数据，提供查找接口，还能建立索引。https://www.ruanyifeng.com/blog/2018/07/indexeddb.html","categories":[{"name":"浏览器","slug":"浏览器","permalink":"https://mandylucky.github.io/categories/%E6%B5%8F%E8%A7%88%E5%99%A8/"}],"tags":[{"name":"浏览器存储","slug":"浏览器存储","permalink":"https://mandylucky.github.io/tags/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%AD%98%E5%82%A8/"}]},{"title":"浏览器缓存","slug":"浏览器/浏览器缓存","date":"2021-05-17T14:08:22.000Z","updated":"2023-06-27T03:33:17.755Z","comments":true,"path":"2021/05/17/浏览器/浏览器缓存/","link":"","permalink":"https://mandylucky.github.io/2021/05/17/%E6%B5%8F%E8%A7%88%E5%99%A8/%E6%B5%8F%E8%A7%88%E5%99%A8%E7%BC%93%E5%AD%98/","excerpt":"","text":"概述浏览器每次发起请求，先在本地缓存中查找结果及缓存标识，根据缓存标识判断是否使用本地缓存，如果缓存有效则使用缓存；否则携带缓存标识向服务器发起请求。 根据是否需要向服务器发起HTTP请求将缓存分为：强缓存、协商缓存【强缓存优于协商缓存】 强缓存:服务器通知浏览器一个缓存时间，在缓存时间内再次发送请求，直接用缓存，不在时间内则进入协商缓存 协商缓存：将缓存信息中的Etag和Last Modified 通过请求发送给服务器，如果服务器校验返回304则直接使用缓存，200 则使用服务器返回的新资源 Http缓存都是从第二次请求开始的 第一次请求资源时，服务器返回资源，并在响应头中回传资源的缓存策略 第二次请求时，浏览器判断这些请求头，命中缓存就直接返回200 使用缓存资源，否则发送请求到服务器，服务端判断，若缓存没有修改则返回304，否则返回新资源。 强缓存控制强缓存字段：Cache-Control(http 1.1) 、Expires (http1.0)Cache-Control &gt; Expires Expires该字段是服务器的响应头字段，告诉浏览器在过期时间(绝对时间)之前可以直接从浏览器缓存中取数据 缺点： 服务器时间和客户端时间可能不一致，这种情况下浏览器判断将出错 到期之前修改，客户端是不可知的 Cache-Control该字段表示资源缓存的最大有效时间（相对时间），在该时间内客户端不需要向服务端发送请求 部分指令: public:所用内容都可以被缓存 （包括：客户端、代理服务器(CDN)） private: 所有内容只有客户端才可以缓存 no-cache: 不使用强缓存，需要与服务器验证缓存是否过期 max-age:最大有效期 no-store: 真正的不要缓存，所有内容不走缓存，包括强缓存和协商缓存 优点：解决了Expires客户端与服务端时间不一致的问题缺点：到期之前修改，客户端是不可知的 协商缓存当浏览器强制缓存失败，或者请求头中设置不走强缓存，并且在请求头设置了if-Modified-Since 或者 if-None-Match 的时候，会将这两个属性值到服务端验证，是否命中协商缓存，如果命中返回304，加载浏览器缓存，并在响应头设置 Etag / Last-Modified 属性 协商缓存有两组字段：Last-Modified/f-Modified-Since 、Etag/if-None-Match Etag &gt; Last-Modified Last-Modified/if-Modified-Since服务器 通过Last-Modified告诉客户端最后一次修改时间，这个值和内容一起保存在缓存中，下一次请求相同资源进入协商缓存时，请求头中奖上一次的Last-Modified值写入到请求头if-Modified-Since字段 优势：相对强制缓存而言，协商缓存每次都会进行比对，有资源更新第一时间获取到。 缺点： 时间修改，但是内容可能没有修改 Last-Modified以秒为单位，如果一秒多次修改数据，客户端只会获取到一秒内第一次修改的内容 Etag/if-None-MatchEtag 是文件的特殊标识（hash生成），流程和Last-Modified一致 优点： 可以识别一秒内多次修改 相对强制缓存而言，协商缓存每次都会进行比对，有资源更新第一时间获取到。 缺点： 计算Etag的值，需要性能消耗 分布式服务器存储要保证Etag 的算法一致","categories":[{"name":"浏览器","slug":"浏览器","permalink":"https://mandylucky.github.io/categories/%E6%B5%8F%E8%A7%88%E5%99%A8/"}],"tags":[{"name":"浏览器缓存","slug":"浏览器缓存","permalink":"https://mandylucky.github.io/tags/%E6%B5%8F%E8%A7%88%E5%99%A8%E7%BC%93%E5%AD%98/"}]},{"title":"浏览器架构","slug":"浏览器/浏览器架构","date":"2021-05-17T14:08:22.000Z","updated":"2023-06-27T03:33:17.755Z","comments":true,"path":"2021/05/17/浏览器/浏览器架构/","link":"","permalink":"https://mandylucky.github.io/2021/05/17/%E6%B5%8F%E8%A7%88%E5%99%A8/%E6%B5%8F%E8%A7%88%E5%99%A8%E6%9E%B6%E6%9E%84/","excerpt":"","text":"// TODO","categories":[{"name":"浏览器","slug":"浏览器","permalink":"https://mandylucky.github.io/categories/%E6%B5%8F%E8%A7%88%E5%99%A8/"}],"tags":[{"name":"浏览器架构","slug":"浏览器架构","permalink":"https://mandylucky.github.io/tags/%E6%B5%8F%E8%A7%88%E5%99%A8%E6%9E%B6%E6%9E%84/"}]},{"title":"浏览器同源政策及其规避方法","slug":"浏览器/浏览器跨域","date":"2021-05-17T14:08:22.000Z","updated":"2023-06-27T03:33:17.755Z","comments":true,"path":"2021/05/17/浏览器/浏览器跨域/","link":"","permalink":"https://mandylucky.github.io/2021/05/17/%E6%B5%8F%E8%A7%88%E5%99%A8/%E6%B5%8F%E8%A7%88%E5%99%A8%E8%B7%A8%E5%9F%9F/","excerpt":"","text":"概述含义浏览器有同源政策 所谓”同源”指的是”三个相同” 域名相同 协议相同 端口相同 目的同源策略的目的是为了保证用户信息的安全，防止恶意的网站窃取数据 限制范围如果是非同源，有三种行为受到限制 Ajax 请求不能发送 DOM 无法获取 Cookie、LocalStorage、IndexDB 无法读取 Cookie 规避同源的方法 iframe 窗口 + 一级域名相同Cookie 只有同源的网页才能共享，但是两个一级域名相同的的网页，浏览器允许通过设置document.domain共享Cookie，这种方法只适用于 Cookie 和 iframe 窗口。 设置Cookie的时候，指定所属域名为一级域名 eg: Set-Cookie: key=value; domain=.example.com; path=/,这样的话二级域名和三级域名都可以读取这个cookie iframe两个网页不同源，就无法拿到对方的DOM。eg:iframe窗口和window.open方法打开的窗口，它们与父窗口无法通信 如果两个窗口一级域名相同，只是二级域名不同那么设置上一节介绍的document.domain属性，就可以规避同源政策，拿到DOM 对于完全不同源的网站片段识别符片段标识符（fragment identifier）指的是，URL的#号后面的部分。如果只是改变片段标识符，页面不会重新刷新。父窗口可以把信息，写入子窗口的片段标识符。 12var src = originURL + &#x27;#&#x27; + data;document.getElementById(&#x27;myIFrame&#x27;).src = src; 子窗口通过监听 hashchange 事件得到通知 123456window.onhashchange = checkMessage;function checkMessage() &#123; var message = window.location.hash; // ...&#125; 同样的，子窗口也可以改变父窗口的片段标识符。 1parent.location.href= target + &quot;#&quot; + hash; window.name浏览器窗口有window.name 属性，该属性无论是否同源，只要在同一个窗口里，前一个网页设置了这个属性，后一个网页可以读取它 12// 主窗口读取子窗口的window.namevar data = document.getElementById(&#x27;myFrame&#x27;).contentWindow.name; 这种方法的优点是，window.name容量很大，可以放置非常长的字符串；缺点是必须监听子窗口window.name属性的变化，影响网页性能 window.postMessageHTML5为了解决这个问题，引入了一个全新的API：跨文档通信APIwindow.postMessage方法，允许跨窗口通信，不论两个窗口是否同源。 12345678// 语法otherWindow.postMessage(message, targetOrigin, [transfer]);// otherWindow:其他窗口的一个引用，比如iframe的contentWindow属性、执行window.open返回的窗口对象、或者是命名过或数值索引的window.frames。// message:将要发送到其他 window的数// targetOrigin :通过窗口的origin属性来指定哪些窗口能接收到消息事件，其值可以是字符串&quot;*&quot;（表示无限制）或者一个URI。 123// 父窗口http://aaa.com向子窗口http://bbb.com发消息，调用postMessage方法就可以了var popup = window.open(&#x27;http://bbb.com&#x27;, &#x27;title&#x27;);popup.postMessage(&#x27;Hello World!&#x27;, &#x27;http://bbb.com&#x27;); 父窗口和子窗口都可以通过message事件，监听对方的消息。 123window.addEventListener(&#x27;message&#x27;, function(e) &#123; console.log(e.data);&#125;,false); message事件的事件对象event，提供以下三个属性 event.source：发送消息的窗口 event.origin: 消息发向的网址 event.data: 消息内容 LocalStorage通过window.postMessage，子窗口将父窗口发来的消息，写入自己的LocalStorage 12345678window.onmessage = function(e) &#123; if (e.origin !== &#x27;http://bbb.com&#x27;) &#123; return; &#125; var payload = JSON.parse(e.data); localStorage.setItem(payload.key, JSON.stringify(payload.data));&#125;; AJAX同源政策规定，AJAX请求只能发给同源的网址，否则就报错。有三种方法规避限制 JSONP WebSocket CORS JSONP优点：最大特点就是简单适用，老式浏览器全部支持，服务器改造非常小。 原理： 它的基本思想是，网页通过添加一个&lt;script&gt;元素，向服务器请求JSON数据，这种做法不受同源政策限制；服务器收到请求后，将数据放在一个指定名字的回调函数里传回来。 1234567891011121314function addScriptTag(src) &#123; var script = document.createElement(&#x27;script&#x27;); script.setAttribute(&quot;type&quot;,&quot;text/javascript&quot;); script.src = src; document.body.appendChild(script);&#125;window.onload = function () &#123; addScriptTag(&#x27;http://example.com/ip?callback=foo&#x27;);&#125;function foo(data) &#123; console.log(&#x27;Your public IP address is: &#x27; + data.ip);&#125;; WebSocketWebSocket是一种通信协议，使用ws://（非加密）和wss://（加密）作为协议前缀。该协议不实行同源政策，只要服务器支持，就可以通过它进行跨源通信。 览器发出的WebSocket请求的头信息有一个字段是Origin，表示该请求的请求源（origin），即发自哪个域名。服务器可以根据这个字段，判断是否许可本次通信。 CORS【跨域资源共享】CORS需要浏览器和服务器同时支持。目前，所有浏览器都支持该功能，IE浏览器不能低于IE10。 整个CORS通信过程，都是浏览器自动完成，浏览器一旦发现AJAX请求跨源，就会自动添加一些附加的头信息。因此，实现CORS通信的关键是服务器。只要服务器实现了CORS接口，就可以跨源通信。 另外，CORS请求默认不发送Cookie和HTTP认证信息。如果要把Cookie发到服务器，一方面要服务器同意，指定Access-Control-Allow-Credentials字段。另一方面，开发者必须在AJAX请求中打开withCredentials属性（设置为true）。 总结 cookie 规避同源的方法 一级域名相同+iframe:document.domain 设置cookie 的时候,domain 设置为.example.com 的形式 iframe (1)域名完全不同 设置hash+ window.onhashchange window.name window.postMessage+ window.addEventListener(‘message’, function(e){}) (2)一级域名相同 document.domain AJAX jsonp websocket cors 阮一峰浏览器同源政策及其规避方法","categories":[{"name":"浏览器","slug":"浏览器","permalink":"https://mandylucky.github.io/categories/%E6%B5%8F%E8%A7%88%E5%99%A8/"}],"tags":[{"name":"浏览器跨域","slug":"浏览器跨域","permalink":"https://mandylucky.github.io/tags/%E6%B5%8F%E8%A7%88%E5%99%A8%E8%B7%A8%E5%9F%9F/"}]},{"title":"Generator 函数的异步应用","slug":"js/es6/Generator-函数的异步应用","date":"2021-05-15T23:34:04.000Z","updated":"2023-06-27T03:33:17.753Z","comments":true,"path":"2021/05/16/js/es6/Generator-函数的异步应用/","link":"","permalink":"https://mandylucky.github.io/2021/05/16/js/es6/Generator-%E5%87%BD%E6%95%B0%E7%9A%84%E5%BC%82%E6%AD%A5%E5%BA%94%E7%94%A8/","excerpt":"","text":"传统方法异步编程的方法，大概有下面四种 回调函数 时间监听 发布/订阅 Promise 对象 Generator 函数将JavaScript 异步编程带入了一个全新的阶段 基本概念所谓”异步”，简单说就是一个任务不是连续完成的，可以理解成该任务被人为分成两段，先执行第一段，然后转而执行其他任务，等做好了准备，再回过头执行第二段。相应地，连续的执行就叫做同步。 回调函数回调函数，就是把任务的第二段单独写在一个函数里面，等到重新执行这个任务的时候，就直接调用这个函数 缺点：回调函数本身并没有问题，它的问题出现在多个回调函数嵌套。代码会横向发展，无法管理。多个异步操作形成了强耦合，只要有一个操作需要修改，它的上层回调函数和下层回调函数，可能都要跟着修改 ，这种情况称为”回调地狱” 12345fs.readFile(fileA, &#x27;utf-8&#x27;, function (err, data) &#123; fs.readFile(fileB, &#x27;utf-8&#x27;, function (err, data) &#123; // ... &#125;);&#125;); PromisePromise 对象是为了解决”回调地狱”问题而提出的。它不是新的语法功能，而是一种新的写法，允许将回调函数的嵌套，改成链式调用。 12345678910111213141516var readFile = require(&#x27;fs-readfile-promise&#x27;);readFile(fileA).then(function (data) &#123; console.log(data.toString());&#125;).then(function () &#123; return readFile(fileB);&#125;).then(function (data) &#123; console.log(data.toString());&#125;).catch(function (err) &#123; console.log(err);&#125;); Promise 提供then方法加载回调函数，catch方法捕捉执行过程中抛出的错误。 Promise 的写法只是回调函数的改进，使用then方法以后，异步任务的两段执行看得更清楚了，除此以外，并无新意。 缺点：Promise 的最大问题是代码冗余，原来的任务被 Promise 包装了一下，不管什么操作，一眼看去都是一堆then，原来的语义变得很不清楚。 Generator 函数协程多个线程相互协作，完成异步任务（多任务的解决方案） 携程有点像函数，又有点像线程，它的运行流程大致如下 第一步，协程A开始执行 第二步，协程A执行到一半，进入暂停，执行权转移到协程B 第三步，一段时间后，协程B交还执行权 第四步，协程A恢复执行 上面流程的协程A，就是异步任务，因为它分成两段（或多段）执行。 协程的 Generator 函数实现Generator 函数是协程在ES6的实现，最大特点是可以交出函数的执行权（既暂停执行） Generator 函数就是一个异步任务的容器，异步操作需要暂停的地方都用yield 语句注明 12345678function* gen(x) &#123; var y = yield x + 2; return y;&#125;var g = gen(1);g.next() // &#123; value: 3, done: false &#125;g.next() // &#123; value: undefined, done: true &#125; next方法的作用是分阶段执行Generator函数。每次调用next方法，会返回一个对象，表示当前阶段的信息（value属性和done属性） value属性是yield语句后面表达式的值，表示当前阶段的值；done属性是一个布尔值，表示 Generator 函数是否执行完毕，即是否还有下一个阶段。 Generator 函数的数据交换和错误处理Generator 函数可以暂停执行和恢复执行，这是它能封装异步任务的根本原因。除此之外，它还有两个特性，使它可以作为异步编程的完整解决方案：函数体内外的数据交换和错误处理机制。 next返回值的 value 属性，是 Generator 函数向外输出数据；next方法还可以接受参数，向 Generator 函数体内输入数据。 Generator 函数内部还可以部署错误处理代码，捕获函数体外抛出的错误。 12345678910111213function* gen(x)&#123; try &#123; var y = yield x + 2; &#125; catch (e)&#123; console.log(e); &#125; return y;&#125;var g = gen(1);g.next();g.throw(&#x27;出错了&#x27;);// 出错了 异步任务的封装123456789101112131415var fetch = require(&#x27;node-fetch&#x27;);function* gen()&#123; var url = &#x27;https://api.github.com/users/github&#x27;; var result = yield fetch(url); console.log(result.bio);&#125;var g = gen();var result = g.next();result.value.then(function(data)&#123; return data.json();&#125;).then(function(data)&#123; g.next(data);&#125;); 虽然 Generator 函数将异步操作表示得很简洁，但是流程管理却不方便（即何时执行第一阶段、何时执行第二阶段）。 Thunk函数Thunk 函数是自动执行Generator 函数的一种方法 参数的求值策略首先了解下编译器求值策略：传值调用、传名调用 1234567// 求值var x = 1;function f(m) &#123; return m * 2;&#125;f(x + 5) 123f(x + 5)// 1.传值调用时，等同于f(6) 123f(x + 5)// 2.传名调用时，等同于(x + 5) * 2 JavaScript语言使用的方式是传值调用，但我们可以用一种其他方法来实现传名调用——Thunk函数！ Thunk 函数的含义编译器的”传名调用“实现，往往将参数放到一个临时函数之中。这个临时函数就叫做Thunk函数。 12345678var thunk = function () &#123; return x + 5;&#125;;function f(thunk) &#123; return thunk() * 2;&#125; 这就是 Thunk 函数的定义，它是“传名调用”的一种实现策略，用来替换某个表达式 或者函数 。 JavaScript 语言的Thunk函数在 JavaScript 语言中，Thunk 函数替换的不是表达式，而是多参数函数，将其替换成一个只接受回调函数作为参数的单参数函数。 任何函数，只要参数有回调函数，就能写成 Thunk 函数的形式。 12345678910111213// 正常版本的readFile（多参数版本）fs.readFile(fileName, callback);// Thunk版本的readFile（单参数版本）var Thunk = function (fileName) &#123; return function (callback) &#123; return fs.readFile(fileName, callback); &#125;;&#125;;var readFileThunk = Thunk(fileName);readFileThunk(callback); 简单版Thunk函数转换器 12345678// ES6版本const Thunk = function(fn) &#123; return function (...args) &#123; return function (callback) &#123; return fn.call(this, ...args, callback); &#125; &#125;;&#125;; 生产环境的转换器建议使用Thunkify 模块 Generator 函数的流程管理Thunk 函数现在可以用于 Generator 函数的自动流程管理。 Generator 函数自动执行,但是这样并不适合异步 1234567function * gen()&#123;&#125;const g=gen()let res=g.next()while(!res.done)&#123; res=g.next()&#125; 如果适合异步操作必须保证前一步操作完成，才执行后一步 yield 命令用于将程序的执行权移出Generator 函数，那么就需要一种方法（Thunk函数），将执行权再交还给Generator 函数 Thunk函数的自动流程管理12345678910var g=gen()var r1=g.next();r1.value(function(err,data)&#123; if(err) throw err; var r2=g.next(data); r2.value(function(err,data)&#123; if(err) throw err; g.next(data) &#125;)&#125;) 12345678910111213141516// 递归实现function run(fn)&#123; var gen=fn(); function next(err,data)&#123; var result=gen.next(data); if(result.done) return result.value(next) &#125; next()&#125;function* g() &#123; // ...&#125;run(g); Thunk 函数并不是 Generator 函数自动执行的唯一方案。因为自动执行的关键是，必须有一种机制，自动控制 Generator 函数的流程，接收和交还程序的执行权。回调函数可以做到这一点，Promise 对象也可以做到这一点。 co模块用于 Generator 函数的自动执行。 1234var co=require(&#x27;co&#x27;);co(gen).then(function ()&#123; console.log(&#x27;Generator 函数执行完成&#x27;);&#125;); Generator 函数只要传入co函数，就会自动执行。co函数返回一个Promise对象，因此可以用then方法添加回调函数。 co模块原理Generator 就是一个异步操作的容器。它的自动执行需要一种机制，当异步操作有了结果，能够自动交回执行权。 两种方法可以做到这一点。 回调函数。将异步操作包装成 Thunk 函数，在回调函数里面交回执行权。 Promise 对象。将异步操作包装成 Promise 对象，用then方法交回执行权。 co 模块其实就是将两种自动执行器（Thunk 函数和 Promise 对象），包装成一个模块。使用 co 的前提条件是，Generator 函数的yield命令后面，只能是 Thunk 函数或 Promise 对象。 12345678910111213// 基于 Promise 对象的自动执行 function run(gen)&#123; var g=gen(); function next(data)&#123; var result=g.next(data) if(result.done) return result.value; result.value.then(function(data)&#123; next(data) &#125;) &#125; next()&#125;run(gen) 1234567891011121314151617181920212223242526272829303132333435// co 模块的源码function co(gen) &#123; var ctx = this; return new Promise(function(resolve, reject) &#123; if (typeof gen === &#x27;function&#x27;) gen = gen.call(ctx); if (!gen || typeof gen.next !== &#x27;function&#x27;) return resolve(gen); onFulfilled(); function onFulfilled(res) &#123; var ret; try &#123; ret = gen.next(res); &#125; catch (e) &#123; return reject(e); &#125; next(ret); &#125; &#125;);&#125;function next(ret) &#123; if (ret.done) return resolve(ret.value); var value = toPromise.call(ctx, ret.value); if (value &amp;&amp; isPromise(value)) return value.then(onFulfilled, onRejected); return onRejected( new TypeError( &#x27;You may only yield a function, promise, generator, array, or object, &#x27; + &#x27;but the following object was passed: &quot;&#x27; + String(ret.value) + &#x27;&quot;&#x27; ) );&#125;","categories":[{"name":"js","slug":"js","permalink":"https://mandylucky.github.io/categories/js/"}],"tags":[{"name":"异步","slug":"异步","permalink":"https://mandylucky.github.io/tags/%E5%BC%82%E6%AD%A5/"},{"name":"ES6","slug":"ES6","permalink":"https://mandylucky.github.io/tags/ES6/"}]},{"title":"Feynman","slug":"thinking/Feynman","date":"2021-05-15T05:36:11.000Z","updated":"2023-06-27T03:33:17.755Z","comments":true,"path":"2021/05/15/thinking/Feynman/","link":"","permalink":"https://mandylucky.github.io/2021/05/15/thinking/Feynman/","excerpt":"","text":"一句话概括费曼学习法：就是学任何东西，如果你能用简单的话，用自己的话，不带行话术语，说给八十岁的老太太听，说给八岁的小孩听。当这些人都听懂了，你就把这个概念搞明白了。 1.讲解+简化：用几个层次和关键词 描述","categories":[{"name":"编程之外","slug":"编程之外","permalink":"https://mandylucky.github.io/categories/%E7%BC%96%E7%A8%8B%E4%B9%8B%E5%A4%96/"}],"tags":[{"name":"学习方法","slug":"学习方法","permalink":"https://mandylucky.github.io/tags/%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%B3%95/"}]},{"title":"STAR","slug":"thinking/star","date":"2021-05-15T05:32:43.000Z","updated":"2023-06-27T03:33:17.755Z","comments":true,"path":"2021/05/15/thinking/star/","link":"","permalink":"https://mandylucky.github.io/2021/05/15/thinking/star/","excerpt":"","text":"描述项目（STAR 法则）情境(situation)、目标（target）、行动(action)、结果(result)结合项目扩展为： 背景：项目背景，是在什么情况下发生的 角色：承担了什么角色 职责：负责工作的哪一方面，协调/开发/… 难题：遇到了什么难题，怎么解决的，为什么这么解决 结果：项目结果如何，有数据支撑更有说服力 沉淀：做完这个项目沉淀了什么，给别人带来什么 复盘：如果重新让你做这件事，你会怎么做，有什么更好的方案 评价：项目中的表现，你周围的小伙伴怎么评价的，上级怎么评价 相关链接https://baike.baidu.com/item/STAR%E6%B3%95%E5%88%99/9056070?fr=aladdin","categories":[{"name":"编程之外","slug":"编程之外","permalink":"https://mandylucky.github.io/categories/%E7%BC%96%E7%A8%8B%E4%B9%8B%E5%A4%96/"}],"tags":[{"name":"STAR","slug":"STAR","permalink":"https://mandylucky.github.io/tags/STAR/"}]},{"title":"构建知识体系","slug":"thinking/构建知识体系","date":"2021-05-15T03:32:27.000Z","updated":"2023-06-27T03:33:17.755Z","comments":true,"path":"2021/05/15/thinking/构建知识体系/","link":"","permalink":"https://mandylucky.github.io/2021/05/15/thinking/%E6%9E%84%E5%BB%BA%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB/","excerpt":"","text":"如何构建自己的知识体系将学习的知识点分类，将不同的知识点建立起链接，最终将所有知识点构建成知识体系 学习识点的 5 Why 背景：技术诞生的背景以及迭代史是什么？ 原理：技术的原理是什么？ 场景：有哪些应用场景？ 比较：横向对比同类技术，各自的优点，缺点是什么？ 未来：未来会支持哪些新特性？","categories":[{"name":"编程之外","slug":"编程之外","permalink":"https://mandylucky.github.io/categories/%E7%BC%96%E7%A8%8B%E4%B9%8B%E5%A4%96/"}],"tags":[{"name":"自我提升","slug":"自我提升","permalink":"https://mandylucky.github.io/tags/%E8%87%AA%E6%88%91%E6%8F%90%E5%8D%87/"}]},{"title":"响应式原理","slug":"js/vue/响应式原理","date":"2021-05-15T00:03:11.000Z","updated":"2023-06-27T03:33:17.754Z","comments":true,"path":"2021/05/15/js/vue/响应式原理/","link":"","permalink":"https://mandylucky.github.io/2021/05/15/js/vue/%E5%93%8D%E5%BA%94%E5%BC%8F%E5%8E%9F%E7%90%86/","excerpt":"","text":"深入响应式原理一、Vue是如何实现响应式对象和数组的?1.初始化阶段,对象变成响应式对象的过程2.对象添加属性&amp;数组2.1对象添加属性2.2数组 二、依赖收集1.Dep2.Watcher3.分析过程 三、派发更新1.分析过程 四、nextTick Vue是如何实现响应式对象和数组的?Vue2.x 实现响应式的核心是利用了 ES5 的 Object.defineProperty(不能兼容 IE8 及以下浏览器) 语法: 12345Object.defineProperty(obj, prop, descriptor)//obj:要定义属性的对象//prop：要定义/修改的属性名称//descriptor:要定义或修改的属性描述符 Object.defineProperty用于在一个对象上定义新属性/修改现有属性，并返回此对象 我们最关心的是descriptor的get和set get 给属性提供getter 方法，当我们访问了该属性的时候会触发getter 方法 set 是一个给属性提供的setter 方法，当我们对该属性做修改的时候会触发setter方法 ==一旦对象拥有了getter和setter，我们就可以简单的把这个对象称为响应式对象== 初始化阶段,对象变成响应式对象的过程props和data 初始化的目的，都是把它们变成响应式对象 props初始化中，props 变成响应式对象的过程 12345678function initProps(propsOptions)&#123; const props = vm._props = &#123;&#125; for (const key in propsOptions) &#123; //.... const value = validateProp(key, propsOptions, propsData, vm) defineReactive(props, key, value) &#125;&#125; data 初始化中，data 变成响应式对象的过程 12345function initData () &#123; //..... observe(data) //把 data 也变成响应式&#125; 12345export function observe (value) &#123;//.....let ob = new Observer(value)return ob&#125; 12345678910111213141516171819202122232425262728export class Observer &#123; constructor (value) &#123; this.value = value //... if (Array.isArray(value)) &#123; const augment = hasProto ? protoAugment : copyAugment augment(value, arrayMethods, arrayKeys) this.observeArray(value) &#125; else &#123; this.walk(value) &#125; &#125; //只有对象才可调用 walk(obj)&#123; for (let i = 0; i &lt; keys.length; i++) &#123; defineReactive(obj, keys[i]) &#125; &#125; observeArray (items) &#123; for (let i = 0, l = items.length; i &lt; l; i++) &#123; observe(items[i]) &#125; &#125;&#125; Observer 构造函数对value判断，纯对象调用walk(遍历对象的key调用defineReactive方法)，若果是数组则调用observeArray方法(遍历数组，再次调用observe) defineReactivedefineReactive 的功能就是定义一个响应式对象，给对象动态添加getter 和 setter 123456789101112131415161718192021222324252627282930export function defineReactive (obj,key,val)&#123; const property = Object.getOwnPropertyDescriptor(obj, key) if (property &amp;&amp; property.configurable === false) &#123; return &#125; const getter = property &amp;&amp; property.get const setter = property &amp;&amp; property.set if ((!getter || setter) &amp;&amp; arguments.length === 2) &#123; val = obj[key] &#125; //.... Object.defineProperty(obj, key, &#123; enumerable: true, configurable: true, get: function reactiveGetter () &#123; const value = getter ? getter.call(obj) : val return value &#125;, set: function reactiveSetter (newVal) &#123; //.... if (setter) &#123; setter.call(obj, newVal) &#125; else &#123; val = newVal &#125; //..... &#125; &#125;)&#125; defineReactive 函数利用Object.defineProperty给数据添加了getter 和 setter 使对象变成了 响应式对象，我们可以在访问数据和写入数据时自动执行一些逻辑来完成响应式 总结：初始化阶段将props 和 data 的变成响应式数据的过程：如果是对象则遍历变量对象的每个属性（configurable 键值为 true），为属性提供getter/setter 方法，如果是数组，修改原型，将其指向arrayMethods(下面会具体说明),遍历数组的每一项进行上述处理 对象添加属性&amp;数组对象添加属性使用Object.defineProperty 实现响应式的对象，当我们去给这个对象添加一个新属性的时候，是不能够触发它的setter 的 这种场景在我们平时开发中经常遇到，那么vue为了解决这个问题，定义了一个全局API Vue.set 方法 global-api/index.js 1Vue.set=set; Vue.set向响应式对象中添加一个 property，并确保这个新 property 同样是响应式的，且触发视图更新。它必须用于向响应式对象上添加新 property，因为 Vue 无法探测普通的新增 property observer/index.js 12345678910111213141516171819202122//target:数组/普通对象//key:代表数组下标或者对象的键值export function set(target,val)&#123; if(Array.isArray(target)&amp;&amp; isValidArrayIndex(key))&#123;//target 是数组且key是合法下标，则通过splice去添加进数组然后返回 target.splice(key, 1, val) //这里的splice不是原生的方法了，而是被Vue 处理过的 return val &#125; if (key in target &amp;&amp; !(key in Object.prototype)) &#123;//对于已经存在与target中的key，直接赋值返回，因为这样的变化是可以被观测到的 target[key] = val return val &#125; const ob = (target: any).__ob__ //__ob__是在Observer 的构造函数执行时初始化的，表示Observer 的一个实例。 //...... if(!ob)&#123;//如果__ob__不存在到的话说明target 不是一个响应式的对象,则直接赋值并返回。 target[key] = val return val &#125; defineReactive(ob.value, key, val)//最后通过defineReactive把新添加的属性变成响应式对象 ob.dep.notify()//手动触发依赖通知 return val&#125; 数组Vue 也不能检测到以下的数组变动 利用索引直接设置一个项时 vm.items[indexOfItem] = newValue 修改数组的长度vm.items.length = newLength 第一个问题的解决方法Vue.set(vm.items, indexOfItem, newValue)第二个问题的解决方法vm.items.splice(indexOfItem, 1, newValue) 其实第一个问题的解决方式本质上与第二个问题的解决方式是一样的，在Vue.set内部会判断如果是数组的话，也是使用splice方法处理 target.splice(key, 1, val) 上面用到的splice 方法是被vue 改写过的方法了，下面会对这部分进行详细的说明 observe 方法观察对象的时候会实例化Observer，在Observer 的构造函数中专门对数组做了处理 1234567891011121314151617export class Observer &#123; constructor (value: any) &#123; this.value = value this.dep = new Dep() this.vmCount = 0 def(value, &#x27;__ob__&#x27;, this) if (Array.isArray(value)) &#123; const augment = hasProto ? protoAugment : copyAugment augment(value, arrayMethods, arrayKeys) this.observeArray(value) &#125; else &#123; // ... &#125; &#125;&#125; hasProto 判断对象中是否存在__proto__,存在augment 指向protoAugment否则指向copyAugment 123function protoAugment (target, src, keys) &#123; target.__proto__ = src&#125; protoAugment 方法是直接把 target.proto 原型直接修改为 src 123456function copyAugment (target, src, keys) &#123; for (let i = 0, l = keys.length; i &lt; l; i++) &#123; const key = keys[i] def(target, key, src[key]) &#125;&#125; copyAugment 方法是遍历 keys，通过 def，也就是 Object.defineProperty 去定义它自身的属性值 大部分现代浏览器会走到protoAugment 1augment(value, arrayMethods, arrayKeys) 那么再看这行代码，实际上就是把value 的原型指向了arrayMethods 123456789101112131415161718192021222324252627282930313233const arrayProto = Array.prototypeexport const arrayMethods = Object.create(arrayProto)const methodsToPatch = [ &#x27;push&#x27;, &#x27;pop&#x27;, &#x27;shift&#x27;, &#x27;unshift&#x27;, &#x27;splice&#x27;, &#x27;sort&#x27;, &#x27;reverse&#x27;] //methodsToPatch中定义了所有能改变数组本身的方法methodsToPatch.forEach(function (method) &#123; const original = arrayProto[method]//缓存原生方法 def(arrayMethods, method, function mutator (...args) &#123; //def 函数是一个非常简单的Object.defineProperty 的封装 const result = original.apply(this, args) const ob = this.__ob__ let inserted switch (method) &#123; case &#x27;push&#x27;: case &#x27;unshift&#x27;: inserted = args break case &#x27;splice&#x27;: inserted = args.slice(2) break &#125; if (inserted) ob.observeArray(inserted) //把新添加的值变成一个响应式对象 // notify change ob.dep.notify()//手动触发依赖通知 return result &#125;)&#125;) arrayMethods首先继承了Array,然后对数组中所有能改变数组自身的方法，eg:push、pop等 方法进行重写。重写后的方法会先执行它们本身原有的逻辑，对能增加长度的3个方法push、unshift、splice 方法做了判断，获取插入的值，然后把新增的值变成一个响应式对象。最后调用ob.dep.notify 手动触发依赖通知 依赖收集Vue 把普通对象变成响应式对象，响应式对象getter 相关逻辑就是做依赖收集的 12345678910111213141516171819202122export function defineReactive (obj,key,val)&#123; const dep = new Dep()//关注1：实例化一个 Dep 的实例 //... Object.defineProperty(obj, key, &#123; enumerable: true, configurable: true, get: function reactiveGetter () &#123; const value = getter ? getter.call(obj) : val if (Dep.target) &#123; dep.depend() //dep.depend 做依赖收集 if (childOb) &#123; childOb.dep.depend() if (Array.isArray(value)) &#123; dependArray(value) &#125; &#125; &#125; return value &#125;, // ... &#125;)&#125; 两个重点关注1.实例化了一个Dep的实例2.getter 中 通过dep.depend 做依赖收集 下面先了解一下Dep DepDep 是整个 getter 依赖收集的核心 123456789101112131415161718192021222324252627282930313233343536373839let uid = 0export default class Dep &#123; //.... static target;// 全局唯一Watcher(同一时间内，只能有一个全局Watcher 被计算) id; subs; constructor () &#123; this.id = uid++ this.subs = [] //watcher 的数组 &#125; addSub(sub)&#123; this.subs.push(sub) &#125; removeSub(sub)&#123; remove(this.subs, sub) &#125; depend () &#123; if (Dep.target) &#123; Dep.target.addDep(this) &#125; &#125; notify () &#123; const subs = this.subs.slice() for (let i = 0, l = subs.length; i &lt; l; i++) &#123; subs[i].update() &#125; &#125;&#125;Dep.target = nullconst targetStack = []export function pushTarget (_target: ?Watcher) &#123; if (Dep.target) targetStack.push(Dep.target) Dep.target = _target&#125;export function popTarget () &#123; Dep.target = targetStack.pop()&#125; Dep 是一个 Class，它定义了一些属性和方法，静态属性target,是一个全局唯一Watcher(同一时间只有一个全局Watcher,因为同一时间只能有一个全局Watcher 被计算)，自身属性subs也是Watcher 的数组 Dep 实际上是对Watcher 的一种管理 下面先了解一下Watcher Watcher123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110let uid = 0export default class Watcher &#123; vm; expression; cb; id; deep; user; computed; sync; dirty; active; dep; deps; newDeps; depIds; newDepIds; before; getter; value; constructor(vm,expOrFn,cb,options,isRenderWatcher)&#123; this.vm = vm if (isRenderWatcher) &#123; vm._watcher = this &#125; vm._watchers.push(this) //options if (options) &#123; this.deep = !!options.deep this.user = !!options.user this.computed = !!options.computed this.sync = !!options.sync this.before = options.before &#125; else &#123; this.deep = this.user = this.computed = this.sync = false &#125; this.cb = cb this.id = ++uid // uid for batching this.active = true this.dirty = this.computed // for computed watchers this.deps = [] this.newDeps = [] this.depIds = new Set() this.newDepIds = new Set() this.expression = process.env.NODE_ENV !== &#x27;production&#x27; ? expOrFn.toString() : &#x27;&#x27; // parse expression for getter if (typeof expOrFn === &#x27;function&#x27;) &#123; this.getter = expOrFn &#125; else &#123; this.getter = parsePath(expOrFn) if (!this.getter) &#123; this.getter = function () &#123;&#125; //正式环境警告！... &#125; &#125; if (this.computed) &#123; this.value = undefined this.dep = new Dep() &#125; else &#123; this.value = this.get() &#125; &#125; get()&#123; pushTarget(this) let value const vm = this.vm try &#123; value = this.getter.call(vm, vm) &#125;catch(e)&#123; //.... &#125;finally&#123; if (this.deep) &#123; traverse(value) &#125; popTarget() this.cleanupDeps() &#125; return value &#125; addDep()&#123; const id = dep.id if (!this.newDepIds.has(id)) &#123; this.newDepIds.add(id) this.newDeps.push(dep) if (!this.depIds.has(id)) &#123; dep.addSub(this) &#125; &#125; &#125; cleanupDeps()&#123; let i = this.deps.length while (i--) &#123; const dep = this.deps[i] if (!this.newDepIds.has(dep.id)) &#123; dep.removeSub(this) &#125; &#125; let tmp = this.depIds this.depIds = this.newDepIds this.newDepIds = tmp this.newDepIds.clear() tmp = this.deps this.deps = this.newDeps this.newDeps = tmp this.newDeps.length = 0 &#125; //....&#125; Watcher 是一个Class,在构造函数中定义了一些和Dep相关的属性 this.deps、this.newDeps:表示 Watcher 实例持有的 Dep 实例的数组 this.depIds、this.newDepIds:分别代表 this.deps 和 this.newDeps 的 id Set Watcher 还定义了一些和依赖收集相关的原型方法。 分析过程访问数据对象会触发getter，下面先说下对象什么时候被访问 Vue 的 mount 过程是通过 mountComponent 函数，其中有一段比较重要的逻辑，如下： 12345678910updateComponent = () =&gt; &#123; vm._update(vm._render(), hydrating)&#125;new Watcher(vm, updateComponent, noop, &#123; before () &#123; if (vm._isMounted) &#123; callHook(vm, &#x27;beforeUpdate&#x27;) &#125; &#125;&#125;, true /* isRenderWatcher */) 上面代码实例化了一个watcher,进入watcher构造函数逻辑，执行this.get()方法，进入get函数首先会执行pushTarget(this)【把 Dep.target 赋值为当前的渲染 watcher 并压栈】，接着执行value = this.getter.call(vm, vm)，this.getter实际上执行的是vm._update(vm._render(), hydrating)，执行vm._render()方法会生成渲染VNode,在这个过程中会对vm上的数据访问，这个时候也就触发了数据对象的getter 每个对象值的getter都一个dep,在触发getter的时候会调用dep.depend()，也就会执行Dep.target.addDep(this) Dep.target 已经被赋值为渲染 watcher,那么就执行到addDep方法 12345678910addDep (dep: Dep) &#123; const id = dep.id if (!this.newDepIds.has(id)) &#123; this.newDepIds.add(id) this.newDeps.push(dep) if (!this.depIds.has(id)) &#123; dep.addSub(this) &#125; &#125;&#125; 做逻辑判断确保同一个数据不会添加多次，然后执行dep.addSub(this),那么就会执行this.subs.push(sub),也就是说把当前watcher订阅到这个数据持有的dep的subs中，为了后续数据变化能够通知到subs vm._render()过程中，会触发所有数据的getter,这样实际上就完成了一个依赖收集的过程 完成依赖收集后，还有几个逻辑要执行 123if (this.deep) &#123; traverse(value)&#125; 这个是要递归去访问 value，触发它所有子项的 getter 123popTarget()//执行Dep.target = targetStack.pop() 实际上就是把 Dep.target 恢复成上一个状态，因为当前 vm 的数据依赖收集已经完成，那么对应的渲染Dep.target 也需要改变 最后执行: 1this.cleanupDeps() Vue 是数据驱动的，所以每次数据变化都会重新 render,那么 vm._render() 方法又会再次执行，并再次触发数据的 getters,所以 Watcher 在构造函数中会初始化 2 个 Dep 实例数组，newDeps 表示新添加的 Dep 实例数组，而 deps 表示上一次添加的 Dep 实例数组。 在执行 cleanupDeps 函数的时候，会首先遍历 deps，移除对 dep.subs 数组中 Wathcer 的订阅，然后把 newDepIds 和 depIds 交换，newDeps 和 deps 交换，并把 newDepIds 和 newDeps 清空。 Vue 设计了在每次添加完新的订阅，会移除掉旧的订阅。这样就保证了。v-if 去渲染不同子模板 a 和 b，如果渲染 b 模板的时候去修改 a 模板的数据，a 数据订阅回调已经被移除了。所以不会有任何浪费。 总结：依赖收集的目的是为了当这些响应数据发生变化，触发它们setter的时候，知道通知哪些订阅者 派发更新响应式数据依赖收集的目的就是为了修改数据时可以对相关依赖派发更新 1234567891011121314151617181920212223export function defineReactive (obj,key,val,customSetter,shallow) &#123; const dep = new Dep() //... Object.defineProperty(obj, key, &#123; enumerable: true, configurable: true, set: function reactiveSetter (newVal) &#123; const value = getter ? getter.call(obj) : val if (newVal === value || (newVal !== newVal &amp;&amp; value !== value)) &#123; return &#125; //... if (setter) &#123; setter.call(obj, newVal) &#125; else &#123; val = newVal &#125; childOb = !shallow &amp;&amp; observe(newVal) dep.notify() &#125; //... &#125;) &#125; setter处理逻辑中有两个关键点，childOb = !shallow &amp;&amp; observe(newVal)如果 shallow 为 false 的情况，会对新设置的值变成一个响应式对象、dep.notify()通知所有订阅者 过程分析当响应式数据做了修改，就会触发setter的逻辑，最后调用dep.notify() 12345678910class Dep &#123; // ... notify () &#123; // stabilize the subscriber list first const subs = this.subs.slice() for (let i = 0, l = subs.length; i &lt; l; i++) &#123; subs[i].update() &#125; &#125;&#125; 遍历subs,也就是Watcher的实例数组，然后调用每个watcher的update 方法 123456789101112class Watcher &#123; // ... update () &#123; if (this.computed) &#123; //... &#125;else if (this.sync) &#123; //... &#125;else &#123; queueWatcher(this) &#125; &#125;&#125; Watcher的不同状态，会执行不同的逻辑，一般组件的数据更新场景会走到queueWatcher(this) 12345678910111213141516171819export function queueWatcher (watcher) &#123; const id = watcher.id if (has[id] == null) &#123; has[id] = true if (!flushing) &#123; queue.push(watcher) &#125; else &#123; let i = queue.length - while (i &gt; index &amp;&amp; queue[i].id &gt; watcher.id) &#123; i-- &#125; queue.splice(i + 1, 0, watcher) &#125; if (!waiting) &#123; waiting = true nextTick(flushSchedulerQueue) &#125; &#125;&#125; 首先用 has 对象保证同一个 Watcher 只添加一次；接着对flushing 判断最后通过waiting保证对 nextTick(flushSchedulerQueue)的调用逻辑只有一次nextTick(flushSchedulerQueue),可以先简单理解为异步的去执行flushSchedulerQueue 下面先看下 flushSchedulerQueue的实现 1234567891011121314151617181920212223242526272829303132let flushing = falselet index = 0function flushSchedulerQueue () &#123; flushing = true let watcher, id queue.sort((a, b) =&gt; a.id - b.id) for (index = 0; index &lt; queue.length; index++) &#123;//queue.length 的原因是用户可能会添加新watcher watcher = queue[index] if (watcher.before) &#123; watcher.before() &#125; id = watcher.id has[id] = null watcher.run() if (process.env.NODE_ENV !== &#x27;production&#x27; &amp;&amp; has[id] != null) &#123; circular[id] = (circular[id] || 0) + 1 if (circular[id] &gt; MAX_UPDATE_COUNT) &#123; warn(xxxx) break &#125; &#125; &#125; const activatedQueue = activatedChildren.slice() const updatedQueue = queue.slice() resetSchedulerState() //状态恢复 callActivatedHooks(activatedQueue) callUpdatedHooks if (devtools &amp;&amp; config.devtools) &#123; devtools.emit(&#x27;flush&#x27;) &#125;&#125; 对上面代码逻辑进行梳理 queue.sort((a, b) =&gt; a.id - b.id)对队列做了从小到大的排序这么做的目的为了确保以下几点： 1.组件的更新由父到子（父组件先于子创建，所以watcher创建也是先父后子，执行顺序也应该保持先父后子）2.用户自定义watcher要优先于渲染watcher执行执行；因为用户自定义watcher在渲染watcher之前创建3.如果一个组件在父组件watcher执行期间被销毁，那么它对应的watcher执行都可以被跳过所以父组件的watcher 也应该先执行 队列遍历排序后进行遍历，获取对应的watcher,执行watcher.run()【因为执行的时候可能会添加新的watcher 所以遍历使用queue.length】 watcher.run()部分逻辑分析 123456789101112131415161718192021222324class Watcher &#123; run()&#123; if (this.active) &#123; this.getAndInvoke(this.cb) &#125; &#125; getAndInvoke(cb)&#123; const value = this.get() if ( value !== this.value || isObject(value) || this.deep)&#123; const oldValue = this.value this.value = value this.dirty = false if (this.user) &#123; try &#123; cb.call(this.vm, value, oldValue) //传入oldValue 这是为什么自定义watcher 中能够得到新旧值的原因啦 &#125; catch (e) &#123; handleError(e, this.vm, `callback for watcher &quot;$&#123;this.expression&#125;&quot;`) &#125; &#125;else&#123; cb.call(this.vm, value, oldValue) &#125; &#125; &#125;&#125; watcher.run() 实际上就是执行 getAndInvoke方法，并传入watcher的回调函数先通过 this.get() 得到它当前的值，然后做判断，如果满足新旧值不等、新值是对象类型、deep 模式任何一个条件，则执行 watcher 的回调 对于渲染watcher而言，执行this.get()方法求值的时候，会执行getter方法，触发组件的重新渲染 状态恢复执行 resetSchedulerState函数,把这些控制流程状态的一些变量恢复到初始。 总结：数据发生变化时，触发setter逻辑，把在依赖过程中订阅的所有观察者（watcher），触发它们的update 过程。这个过程利用队列做了进一步优化，在nextTick后执行所有watcher的run ,最后执行它们的回调函数 nextTicknextTick 是Vue的一个核心实现 先了解JS运行机制 所有同步任务都在主线程上执行，形成一个执行栈 主线程之外还存在一个任务队列，只有异步任务有了运行结果，就在任务队列中放置一个事件 执行栈中所有同步任务执行完毕，就会读取任务对列，进入执行栈，开始执行 主线程不断重复第三步 主线程的执行过程就是一个tick，而所有的异步结果都是通过 “任务队列” 来调度。消息队列中存放的是一个个的任务（task）。 规范中规定 task 分为两大类，分别是 macro task 和 micro task macro task 和 micro task 伪代码表示 123456789for (macroTask of macroTaskQueue) &#123; // 1. Handle current MACRO-TASK handleMacroTask(); // 2. Handle all MICRO-TASK for (microTask of microTaskQueue) &#123; handleMicroTask(microTask); &#125;&#125; Vue的实现 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485const callbacks = []let pending = falsefunction flushCallbacks () &#123; pending = false const copies = callbacks.slice(0) callbacks.length = 0 for (let i = 0; i &lt; copies.length; i++) &#123; copies[i]() &#125;&#125;let microTimerFunclet macroTimerFunclet useMacroTask = falseif (typeof setImmediate !== &#x27;undefined&#x27; &amp;&amp; isNative(setImmediate)) &#123; macroTimerFunc = () =&gt; &#123; setImmediate(flushCallbacks) &#125;&#125; else if (typeof MessageChannel !== &#x27;undefined&#x27; &amp;&amp; ( isNative(MessageChannel) || // PhantomJS MessageChannel.toString() === &#x27;[object MessageChannelConstructor]&#x27;)) &#123; const channel = new MessageChannel() const port = channel.port2 channel.port1.onmessage = flushCallbacks macroTimerFunc = () =&gt; &#123; port.postMessage(1) &#125;&#125; else &#123; /* istanbul ignore next */ macroTimerFunc = () =&gt; &#123; setTimeout(flushCallbacks, 0) &#125;&#125;if (typeof Promise !== &#x27;undefined&#x27; &amp;&amp; isNative(Promise)) &#123; const p = Promise.resolve() microTimerFunc = () =&gt; &#123; p.then(flushCallbacks) // in problematic UIWebViews, Promise.then doesn&#x27;t completely break, but // it can get stuck in a weird state where callbacks are pushed into the // microtask queue but the queue isn&#x27;t being flushed, until the browser // needs to do some other work, e.g. handle a timer. Therefore we can // &quot;force&quot; the microtask queue to be flushed by adding an empty timer. if (isIOS) setTimeout(noop) &#125;&#125; else &#123; // fallback to macro microTimerFunc = macroTimerFunc&#125;export function nextTick(cb,ctx)&#123; let _resolve callbacks.push(() =&gt; &#123; if (cb) &#123; try &#123; cb.call(ctx) &#125; catch (e) &#123; handleError(e, ctx, &#x27;nextTick&#x27;) &#125; &#125; else if (_resolve) &#123; _resolve(ctx) &#125; &#125;) if (!pending) &#123; pending = true if (useMacroTask) &#123; macroTimerFunc() &#125; else &#123; microTimerFunc() &#125; &#125; if (!cb &amp;&amp; typeof Promise !== &#x27;undefined&#x27;) &#123; return new Promise(resolve =&gt; &#123; _resolve = resolve &#125;) &#125; &#125; macro tast函数：优先检测是否支持原生setImmediate,不支持的话检查是否支持原生MessageChannel,如果也不支持就会降级为setTimeout micro task函数：检查浏览器是否原生支持promise,不支持的话直接指向macro task nexTick：把传入的回调函数cb压入callbacks数组，最后一次性地根据useMacroTask 条件执行macroTimerFunc || microTimerFunc，而它们都会在下一个 tick 执行 flushCallbacks（flushCallbacks是对 callbacks 遍历，然后执行相应的回调函数） 使用callbacks 而不是直接在nextTick执行回调函数的原因是保证在同一个tick 多次执行nextTick，不会启多个异步任务，而是把这些异步任务都压成一个同步任务，在下一个tick 执行","categories":[{"name":"Vue","slug":"Vue","permalink":"https://mandylucky.github.io/categories/Vue/"}],"tags":[{"name":"Vue深入浅出读书笔记","slug":"Vue深入浅出读书笔记","permalink":"https://mandylucky.github.io/tags/Vue%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"},{"name":"响应式原理","slug":"响应式原理","permalink":"https://mandylucky.github.io/tags/%E5%93%8D%E5%BA%94%E5%BC%8F%E5%8E%9F%E7%90%86/"}]},{"title":"Generator基础","slug":"js/es6/Generator基础","date":"2021-05-13T23:00:00.000Z","updated":"2023-06-27T03:33:17.753Z","comments":true,"path":"2021/05/14/js/es6/Generator基础/","link":"","permalink":"https://mandylucky.github.io/2021/05/14/js/es6/Generator%E5%9F%BA%E7%A1%80/","excerpt":"","text":"概述基础概念Generator 函数有多种理解角度 语法上，Generator 函数是一个状态机，封装了多个内部状态 执行Generator 函数会返回一个遍历器对象，所有Generator 也是一个遍历器对象生成函数，返回遍历器对象 形式上，Generator 函数是一个普通函数，有两个特征 一个是function 关键字和函数名直接有一个星号，二是，函数体内部使用yield（产出） 表达式，定义不同的状态 1234567891011121314151617function* helloWorldGenerator() &#123; yield &#x27;hello&#x27;; yield &#x27;world&#x27;; return &#x27;ending&#x27;;&#125;var hw = helloWorldGenerator();hw.next()// &#123; value: &#x27;hello&#x27;, done: false &#125;hw.next()// &#123; value: &#x27;world&#x27;, done: false &#125;hw.next()// &#123; value: &#x27;ending&#x27;, done: true &#125;hw.next()// &#123; value: undefined, done: true &#125; 遇到yield 表达式就会暂停，下一次调用会从上一次暂停的地方一直执行到下一个yield/return ,每次调用都会返回&#123;value:xxx,done:true/false&#125; yield 表达式由于 Generator 函数返回的遍历器对象，只有调用next方法才会遍历下一个内部状态，所以其实提供了一种可以暂停执行的函数。yield表达式就是暂停标志。 yield表达式只能用在 Generator 函数里面,用在其他地方都会报错 遍历器对象的next方法运行逻辑： 遇到yild 表达式，暂停执行后面操作，yield 表达式的值作为返回对象的value属性值 下一次调用next方法时，再继续往下执行，直到遇到下一个yield表达式。 如果没有再遇到新的yield表达式，就一直运行到函数结束，直到return语句为止，并将return语句后面的表达式的值，作为返回的对象的value属性值 如果该函数没有return语句，则返回的对象的value属性值为undefined。 Generator 不用yield 表达式，变成了一个单纯的暂缓执行函数 12345678function * f()&#123; console.log(&#x27;执行&#x27;)&#125;var generator = f();setTimeout(function () &#123; generator.next()&#125;, 2000); 函数f是一个 Generator 函数，就变成只有调用next方法时，函数f才会执行。 与Iterator 接口的关系 Symbol.iterator方法，等于该对象的遍历器生成函数，调用该函数会返回该对象的一个遍历器对象。 由于 Generator 函数就是遍历器生成函数，因此可以把 Generator 赋值给对象的Symbol.iterator属性，从而使得该对象具有 Iterator 接口。 Generator 函数执行后，返回一个遍历器对象。该对象本身也具有Symbol.iterator属性，执行后返回自身。 12345function* gen()&#123; // some code&#125;var g = gen();g[Symbol.iterator]() === g next 方法的参数yield表达式本身没有返回值，或者说总是返回undefined。next方法可以带一个参数，该参数就会被当作上一个yield表达式的返回值。 for…of 循环for…of循环可以自动遍历 Generator 函数运行时生成的Iterator对象，且此时不再需要调用next方法。 12345678910111213function* foo() &#123; yield 1; yield 2; yield 3; yield 4; yield 5; return 6;&#125;for (let v of foo()) &#123; console.log(v);&#125;// 1 2 3 4 5 Generator.prototype.throw()Generator 函数返回的遍历器对象，都有一个throw方法，可以在函数体外抛出错误，然后在 Generator 函数体内捕获。 12345678910111213141516var g=function * ()&#123; try&#123; yield &#125;catch(e)&#123; console.log(&#x27;内部捕获&#x27;,e) &#125;&#125;var i=g()try&#123; i.throw(&#x27;a&#x27;) i.throw(&#x27;b&#x27;);&#125;catche(e)&#123; console.log(&#x27;外部捕获&#x27;，e)&#125;// 内部捕获 a// 外部捕获 b 第一个错误被 Generator 函数体内的catch语句捕获。i第二次抛出错误，由于 Generator 函数内部的catch语句已经执行过了，不会再捕捉到这个错误了，所以这个错误就被抛出了 Generator 函数体，被函数体外的catch语句捕获。 如果 Generator 函数内部没有部署try…catch代码块，那么throw方法抛出的错误，将被外部try…catch代码块捕获。 Generator.prototype.return()1234567891011function* gen() &#123; yield 1; yield 2; yield 3;&#125;var g = gen();g.next() // &#123; value: 1, done: false &#125;g.return(&#x27;foo&#x27;) // &#123; value: &quot;foo&quot;, done: true &#125;g.next() try…finally 代码块正在执行try代码块，那么return()方法会导致立刻进入finally代码块，然后等到finally代码块执行完，再返回return()方法指定的返回值 1234567891011121314151617function* numbers () &#123; yield 1; try &#123; yield 2; yield 3; &#125; finally &#123; yield 4; yield 5; &#125; yield 6;&#125;var g = numbers();g.next() // &#123; value: 1, done: false &#125;g.next() // &#123; value: 2, done: false &#125;g.return(7) // &#123; value: 4, done: false &#125;g.next() // &#123; value: 5, done: false &#125;g.next() // &#123; value: 7, done: true &#125; next()、throw()、return() 的共同点next()、throw()、return()这三个方法本质上是同一件事，可以放在一起理解。它们的作用都是让 Generator 函数恢复执行，并且使用不同的语句替换yield表达式。 next()是将yield表达式替换成一个值。 throw()是将yield表达式替换成一个throw语句。 return()是将yield表达式替换成一个return语句。 yield* 表达式yield表达式后面跟的是一个遍历器对象，需要在yield表达式后面加上星号，表明它返回的是一个遍历器对象。这被称为yield*表达式。 使用场景Generator 函数嵌套，写起来就非常麻烦。eg:foo 和 bar 都是generator函数，在bar 里面调用foo,就需要手动遍历foo (使用：for … of) 123456789101112131415161718192021function* foo() &#123; yield &#x27;a&#x27;; yield &#x27;b&#x27;;&#125;function* bar() &#123; yield &#x27;x&#x27;; // 手动遍历 foo() for (let i of foo()) &#123; console.log(i); &#125; yield &#x27;y&#x27;;&#125;for (let v of bar())&#123; console.log(v);&#125;// x// a// b// y ES6 提供了yield 表达式解决Generator 函数嵌套问题* 123456789101112131415161718function* foo() &#123; yield &#x27;a&#x27;; yield &#x27;b&#x27;;&#125;function* bar() &#123; yield &#x27;x&#x27;; yield* foo(); yield &#x27;y&#x27;;&#125;// 等同于function* bar() &#123; yield &#x27;x&#x27;; yield &#x27;a&#x27;; yield &#x27;b&#x27;; yield &#x27;y&#x27;;&#125; 作为对象属性的 Generator 函数123456789101112let obj = &#123; myGeneratorMethod: function* () &#123; // ··· &#125;&#125;;// 等价于let obj = &#123; * myGeneratorMethod() &#123; ··· &#125;&#125;; myGeneratorMethod属性前面有一个星号，表示这个属性是一个 Generator 函数。 Generator 函数的thisGenerator 函数总是返回一个遍历器，ES6 规定这个遍历器是 Generator 函数的实例，也继承了 Generator 函数的prototype对象上的方法。 generator 函数不能作为构造函数，也不能使用 new调用,有没有办法让 Generator 函数返回一个正常的对象实例，既可以用next方法，又可以获得正常的this？ 12345678910111213141516171819function* gen() &#123; this.a = 1; yield this.b = 2; yield this.c = 3;&#125;function F() &#123; return gen.call(gen.prototype);&#125;var f = new F();f.next(); // Object &#123;value: 2, done: false&#125;f.next(); // Object &#123;value: 3, done: false&#125;f.next(); // Object &#123;value: undefined, done: true&#125;f.a // 1f.b // 2f.c // 3 含义Generator 与状态机Generator 是实现状态机的最佳结构 例子：clock函数一共有两种状态（Tick和Tock），每运行一次，就改变一次状态 12345678910111213141516171819var ticking = true;var clock = function() &#123; if (ticking) console.log(&#x27;Tick!&#x27;); else console.log(&#x27;Tock!&#x27;); ticking = !ticking;&#125;// 等价于var clock = function* () &#123; while (true) &#123; console.log(&#x27;Tick!&#x27;); yield; console.log(&#x27;Tock!&#x27;); yield; &#125;&#125;; Generator 与协程协程（coroutine）是一种程序运行的方式，可以理解成”协作的函数” Generator 函数是 ES6 对协程的实现，但属于不完全实现。Generator 函数被称为“半协程”（semi-coroutine），意思是只有 Generator 函数的调用者，才能将程序的执行权还给 Generator 函数。如果是完全执行的协程，任何函数都可以让暂停的协程继续执行。 如果将 Generator 函数当作协程，完全可以将多个需要互相协作的任务写成 Generator 函数，它们之间使用yield表达式交换控制权。 Generator 与上下文Generator 函数执行产生的上下文环境，一旦遇到yield命令，就会暂时退出堆栈，但是并不消失，里面的所有变量和对象会冻结在当前状态。等到对它执行next命令时，这个上下文环境又会重新加入调用栈，冻结的变量和对象恢复执行 应用Generator 可以暂停函数执行，返回任意表达式的值。这种特点使得 Generator 有多种应用场景。 异步操作的同步化表达123456789101112function * main()&#123; var result=yield request(&quot;http://some.url&quot;); var resp=JSON.parse(result); console.log(resp.value)&#125;function request(url)&#123; makeAjaxCall(url,function(response)&#123; it.next(response) &#125;)&#125;var it=main();it.next() 控制流管理12345678910111213141516171819202122232425262728293031323334353637383940414243// 多个步骤的操作，使用回调函数step1(function (value1) &#123; step2(value1, function(value2) &#123; step3(value2, function(value3) &#123; step4(value3, function(value4) &#123; // Do something with value4 &#125;); &#125;); &#125;);&#125;);// 多个步骤的操作，使用PromisePromise.resolve(step1) .then(step2) .then(step3) .then(step4) .then(function (value4) &#123; // Do something with value4 &#125;, function (error) &#123; // Handle any error from step1 through step4 &#125;) .done(); // 多个步骤的操作，Generatorfunction* longRunningTask(value1) &#123; try &#123; var value2 = yield step1(value1); var value3 = yield step2(value2); var value4 = yield step3(value3); var value5 = yield step4(value4); // Do something with value4 &#125; catch (e) &#123; // Handle any error from step1 through step4 &#125;&#125;// generator 自动执行函数function secheduler(task)&#123; let value; var taskObj=task.next(value); if(!taskObj.done)&#123; value=taskObj.value; secheduler(task) &#125;&#125; 1234567891011121314151617181920// 利用for...of循环会自动依次执行yield命令的特性，提供一种更简单的控制流管理的方法。let steps = [step1Func, step2Func, step3Func];function* iterateSteps(steps)&#123; for (var i=0; i&lt; steps.length; i++)&#123; var step = steps[i]; yield step(); &#125;&#125;let jobs = [job1, job2, job3];function* iterateJobs(jobs)&#123; for (var i=0; i&lt; jobs.length; i++)&#123; var job = jobs[i]; yield* iterateSteps(job.steps); &#125;&#125;for (var step of iterateJobs(jobs))&#123; console.log(step.id);&#125; 部署 Iterator 接口利用Generator函数可以在任意对象上部署Iterator 接口123456789101112function * iterEntries(obj)&#123; let keys=Object.keys(obj); for(let i=0;i&lt;keys.length;i++)&#123; let key=keys[i]; yield [key,obj[key]] &#125;&#125;let myObj=&#123;foo:3,bar:7&#125;for(let [key,val] of iterEntries(myObj))&#123; console.log(key,val)&#125; 作为数据结构Generator 可以看作是一个数组结构，因为 Generator 函数可以返回一系列的值，这意味着它可以对任意表达式，提供类似数组的接口。 123456789101112131415161718// Generator 写法function* doStuff() &#123; yield fs.readFile.bind(null, &#x27;hello.txt&#x27;); yield fs.readFile.bind(null, &#x27;world.txt&#x27;); yield fs.readFile.bind(null, &#x27;and-such.txt&#x27;);&#125;// ES5 写法function doStuff() &#123; return [ fs.readFile.bind(null, &#x27;hello.txt&#x27;), fs.readFile.bind(null, &#x27;world.txt&#x27;), fs.readFile.bind(null, &#x27;and-such.txt&#x27;) ];&#125;for (task of doStuff()) &#123; // task是一个函数，可以像回调函数那样使用它&#125; 上面的函数，可以用一模一样的for…of循环处理！两相一比较，可以看出 Generator 使得数据或者操作，具备了类似数组的接口。","categories":[{"name":"js","slug":"js","permalink":"https://mandylucky.github.io/categories/js/"}],"tags":[{"name":"ES6","slug":"ES6","permalink":"https://mandylucky.github.io/tags/ES6/"}]},{"title":"Iterator","slug":"js/es6/iterator","date":"2021-05-13T00:35:38.000Z","updated":"2023-06-27T03:33:17.754Z","comments":true,"path":"2021/05/13/js/es6/iterator/","link":"","permalink":"https://mandylucky.github.io/2021/05/13/js/es6/iterator/","excerpt":"","text":"概念JavaScript 有四种数据集合：Array、Object、Map、Set ,我们可以组合使用它们定义数据结构，这样就需要一种统一的接口机制来处理不同的数据结构 遍历器（Iterator）：它是一个接口，为各种不同的数据结构提供统一的访问机制，任何数据结构只要部署了Iterator 接口，就可以完成遍历操作 Iterator 作用 为不同数据结构提供统一的访问接口 使数据结构的成员能够按某种次序排序 ES6 新的遍历方式for…of，Iterator 接口主要提供for .. of 消费 Iterator的遍历过程 创建一个指针对象，指向当前数据结构的起始位置 （遍历器的本质就是一个指针对象) 第二次调用next方法，指针指向数据结构的第二个成员 不断调用指针对的next 方法，直到指向数据结构的结束位置 模拟遍历器生成函数12345678910function makeIterator(array)&#123; var nextIndex=0; return &#123; next:function()&#123; return nextIndex&lt;array.length? &#123;value:array[nextIndex++]&#125; : &#123;done:true&#125; &#125; &#125;&#125; 遍历器与数据结构是分离的 默认 Iterator 接口 Iterator 接口的目的，就是为所有数据结构，提供了一种统一的访问机制，即for…of循环。当使用for…of循环遍历某种数据结构时，该循环会自动去寻找 Iterator 接口。 一种数据结构只要部署了 Iterator 接口，我们就称这种数据结构是“可遍历的” ES6 规定，默认的 Iterator 接口部署在数据结构的Symbol.iterator属性,也就是说一个数据结构只要有Symbol.iterator 数据就可以认为是可遍历的 Symbol.iterator属性本身是一个函数，就是当前数据结构默认的【遍历器生成函数】。执行这个函数，就会返回一个遍历器 原生具备 Iterator 接口的数据结构如 Array Map Set String arguments 对象 NodeList 对象 调用Iterator 接口的场合 解构赋值 会默认调用Symbol.iterator 方法 扩展运算符 也会默认调用Iterator 接口 yield* 后面跟的是一个可遍历结构，它也会调用该结构的遍历器接口。 for…of 、Array.from()、Map() 、Set()、WeakMap()、WeakSet()、Promise.all()、Promise.race() 字符串的Iterator 接口字符串也原生具有Iterator 接口 123456var someStr=&quot;hi&quot;;typeof someStr[Symbol.iterator]var iterator =someStr[Symbol.iterator]()iterator.next(); // &#123;value:&quot;h&quot;,done:false&#125;iterator.next(); // &#123;value:&quot;i&quot;,done:false&#125;iterator.next(); // &#123;value:undefined,done:true&#125; Symbol.iterator方法返回一个遍历器对象，在遍历器对象上可以调用next方法，实现对于字符串的遍历。也可以覆盖Symbol.iterator 方法，达到修改遍历器行为的目的 遍历器对象的return(),throw()遍历器对象除了具有next()方法，还具有return()、throw()方法。自定义的遍历器对象必须部署next()方法，return()和throw()方法是否部署是可选择的 return()方法:break 或者 出错 会触发执行return()方法 123456789101112131415function readLinesSync(file) &#123; return &#123; [Symbol.iterator]() &#123; return &#123; next() &#123; return &#123; done: false &#125;; &#125;, return() &#123; file.close(); return &#123; done: true &#125;; &#125; &#125;; &#125;, &#125;;&#125; throw()方法主要配合Generator 函数使用 for…of 循环一个数据结构只要部署了Symbol.iterator 属性，就被是为具有iterator 接口，就可以用 for…of 循环遍历它的成员。也就是说for…of 循环内部调用的是数据结构的Symbol.iterator 方法 for…in循环读取键名，for…of循环读取键值。 123456789var arr = [&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;, &#x27;d&#x27;];for (let a in arr) &#123; console.log(a); // 0 1 2 3&#125;for (let a of arr) &#123; console.log(a); // a b c d&#125; 计算生成的数据结构有些数据结构是在现有数据结构的基础上，计算生成的。eg:数组、Set、Map 都部署了以下三个方法，调用后都返回遍历器对象 entries() 返回一个遍历器对象，用来遍历[键名，键值]组成的数组，数组的键名就是索引，Set 的键名，键值相同，Map结构的Iterator 结构默认就是调用entries方法 keys() 返回一个遍历器对象，用来遍历所有的键名 values() 返回一个遍历器对象，用来遍历所有的键值 与其他遍历语法的比较 for循环:写法麻烦 123for (var index = 0; index &lt; myArray.length; index++) &#123; console.log(myArray[index]);&#125; 数组内置方法forEach:无法中途跳出forEach循环，break或者return 命令不能奏效 123myArray.forEach(function (value) &#123; console.log(value);&#125;); for…in循环：遍历键名。缺点 数组的键名是数字，但是for…in 循环是以字符串作为键名 会遍历原型链上的键。 以任意顺序遍历总之，for…in循环主要是为遍历对象而设计的，不适用于遍历数组。 for …of 循环优点 有着同for…in一样的简洁语法，但是没有for…in那些缺点 它可以与break、continue和return配合使用 提供了遍历所有数据结构的统一操作接口。 相关链接阮一峰ES6","categories":[{"name":"js","slug":"js","permalink":"https://mandylucky.github.io/categories/js/"}],"tags":[{"name":"ES6","slug":"ES6","permalink":"https://mandylucky.github.io/tags/ES6/"}]},{"title":"对象","slug":"js/对象","date":"2021-05-12T15:35:38.000Z","updated":"2023-06-27T03:33:17.754Z","comments":true,"path":"2021/05/12/js/对象/","link":"","permalink":"https://mandylucky.github.io/2021/05/12/js/%E5%AF%B9%E8%B1%A1/","excerpt":"","text":"语法两种形式定义:声明(文字)形式、构造形式 12345678// 文字形式var myObj=&#123; key:value //...&#125;// 构造形式var myObj=new Object();myObj.key=value 类型数组是对象的一种子类型，函数也是对象的一种子类型，内置对象（String、Number、Boolean、Object、Function、Array、Date、RegExp、Error） 也是对象的一种子类型 123456var str=&quot;i am a string&quot;;typeof str;//stringstr.length //13var strObject=new String(&quot;i am a string&quot;);typeof strObject //&quot;object&quot; 之所以能在字面量上面直接访问属性或者方法，因为引擎自动把字面量转换成string对象，所以可以访问属性和方法 null和undefined 没有对应的构造形式，只有文字 Date 只有构造形式，没有文字 Object、Array、Function、RegExp 无论使用文字形式还是构造形式，他们都是对象 Error 对象一般都是在抛出异常时自动创建 内容 对象的属性名永远都是字符串 访问属性：两种方式 . 和 [“..”],. 要求属性名满足标识符命名规范，[“..”] 语法可以接收任意字符串 可计算属性名使用[]包裹一个表达式来当作属性名，最常用的场景是ES6 的Symbol 123456const prefix=&quot;foo&quot;;const key1 = Symbol(&#x27;description&#x27;);var myObj=&#123; [prefix+&#x27;bar&#x27;]:&quot;hello&quot; [key1]:&quot;world&quot;&#125; 属性与方法如果访问对象属性是一个函数，被称为 “方法访问”，其他情况称为 “属性访问” 复制对象浅拷贝：Object.assign()深拷贝：JSON.parse(JSON.stringify(someObj)) 属性描述符ES5之后所有属性都具备了属性描述符 12345678910var myObj=&#123; a:2&#125;Object.getOwnPropertyDescriptor(myObj,&quot;a&quot;)// &#123;// value:2,// writable:true,// enumerable:true,// configurable:true// &#125; 创建普通属性时属性描述符会有默认值,我们也可以使用Object.defineProperty(...)来添加一个新属性或者修改一个已有属性（configurable为true时）并对其特性进行配置 12345678var myObject=&#123;&#125;Object.defineProperty(myObject,&quot;a&quot;,&#123; value:2, writable:true, configurable:true, enumerable:true&#125;)myObject.a //2 Writable: 决定是否可以修改属性值 Configurable: 设置属性是否可配置，只要属性是可配置的就可以使用defineProperty(…)方法来修改属性描述符。configurable 只能由true 改为false ,不能由false 改为true。且不能删除属性 delete 语句会失败 Enumerable: 用于控制属性是否会出现在对象的属性枚举中。 getter 后面会详细介绍 setter 后面会详细介绍 不变性 对象常量结合writeable:false 和 configurable 就可以创建一个真正的常量属性（不可修改，从定义或者删除） 123456var myObj=&#123;&#125;Object.defineProperty(myObj,&quot;FAVORITE_NUMBER&quot;,&#123; value:42; writable:false, configurable:false&#125;) 禁止扩展(prevent Extensions)Object.preventExtensions(…) 禁止一个对象添加新属性，但是可以修改已有属性值 或者 删除已有属性 密封(seal)Object.seal(…) 会创建一个”密封”的对象，这个方法等价于Object.preventExtensions(…)+configurable:false。密封之后不仅不能添加新属性，也不能重新配置或者删除现有属性（可以改属性值） 冻结(freeze)Object.freeze(…) 会创建一个冻结对象，这个方法等价于Object.seal(…)+writable:false,这个方法是对象上的级别最高的不可变性，它会禁止对对象本身及其任意直接属性的修改 深度冻结一个对象 tips:冻结对象中如果引用了其他对象，也会被冻结Object.freeze(…) 在Vue中可用于大列表的性能优化[[Get]] 获取属性值操作 对象默认内置[[Get]]操作，该操作首先在对象中查找是否有名称相同的属性，有则返回属性值。没有会返回undefined [[Put]] 属性赋值操作 对象已存在这个属性 属性是否是访问描述符？如果是存在setter则调用setter 属性数据描述中 writable 是否是false,是非严格失败 、严格TypeError 如果都不是，该值设置为属性的值 对象中不存在这个属性 TODO 待补充… Getter 和 Setter对象默认的[[Put]] 和 [[Get]] 操作分别可以控制属性值的 设置和获取ES5中 getter 和 setter 可以 改写默认操作 当一个属性定义了 getter 或setter 描述符 这个属性就被定义为”访问描述符”，没有getter 或 setter 的被称为 “数据描述符”。 访问描述符 会忽略 value 和 wirtable,关注 getter 、setter 、configurable 、enumerable 存在性判断对象中是否存在该属性 in 操作符：会检查是否在对象及 [[Prototype]] 链 hasOwnProperty：只会检查属性是否在对象中，不会检查 [[Prototype]] 链 枚举：enumerablefor … in 遍历对象时 ，只会遍历可枚举的属性(包括 [[Prototype]] 链) tips: 建议遍历数组使用for 循环，且只在遍历对象上应用 for…in 123for (var k in obj)&#123; console.log(k,obj[k])&#125; for…in 遍历对象时无法直接获取属性值，需要手动获取属性值 ES6新增 for...of用于遍历可迭代对象（Array、Map 、Set 、String、arguments …） for…of 循环首先会向访问对象请求一个迭代器对象，然后通过调用迭代器对象的next()方法来遍历返回所以值 rray、Map 、Set 、String、arguments 这些可迭代对象都内置了@@iterator 1234567// 手动遍历var myArray=[1,2,3,4]var it=myArray[Symbol.iterator]()it.next();//&#123;value:1,done:false&#125;it.next();//&#123;value:2,done:false&#125;it.next();//&#123;value:3,done:false&#125;it.next();//&#123;done:true&#125; 相关知识点Iterator","categories":[{"name":"js","slug":"js","permalink":"https://mandylucky.github.io/categories/js/"}],"tags":[{"name":"你不知道的js读书笔记","slug":"你不知道的js读书笔记","permalink":"https://mandylucky.github.io/tags/%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84js%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"},{"name":"js基础","slug":"js基础","permalink":"https://mandylucky.github.io/tags/js%E5%9F%BA%E7%A1%80/"}]},{"title":"排序","slug":"算法/排序","date":"2021-05-11T05:20:01.000Z","updated":"2023-06-27T03:33:17.755Z","comments":true,"path":"2021/05/11/算法/排序/","link":"","permalink":"https://mandylucky.github.io/2021/05/11/%E7%AE%97%E6%B3%95/%E6%8E%92%E5%BA%8F/","excerpt":"","text":"TODO 待补充…","categories":[{"name":"算法","slug":"算法","permalink":"https://mandylucky.github.io/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"算法基础","slug":"算法基础","permalink":"https://mandylucky.github.io/tags/%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80/"}]},{"title":"查找","slug":"算法/查找","date":"2021-05-11T05:20:01.000Z","updated":"2023-06-27T03:33:17.755Z","comments":true,"path":"2021/05/11/算法/查找/","link":"","permalink":"https://mandylucky.github.io/2021/05/11/%E7%AE%97%E6%B3%95/%E6%9F%A5%E6%89%BE/","excerpt":"","text":"TODO 待补充…","categories":[{"name":"算法","slug":"算法","permalink":"https://mandylucky.github.io/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"算法基础","slug":"算法基础","permalink":"https://mandylucky.github.io/tags/%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80/"}]},{"title":"树","slug":"算法/树","date":"2021-05-11T05:20:01.000Z","updated":"2023-06-27T03:33:17.755Z","comments":true,"path":"2021/05/11/算法/树/","link":"","permalink":"https://mandylucky.github.io/2021/05/11/%E7%AE%97%E6%B3%95/%E6%A0%91/","excerpt":"","text":"前端工作中常见的树：DOM树、级联选择、树形控件… js中没有树，但是可以使用Object 和 Array 构建树 树的常用操作：深度/广度 优先遍历、前中后序遍历 深度优先遍历深度优先遍历，尽可能深的搜索树的分支 访问根节点 对根节点children 挨个进行深度优先遍历12345678910111213141516171819202122232425262728const tree=&#123; val:&#x27;a&#x27;, children:[&#123; val:&#x27;b&#x27;, children:[&#123; val:&#x27;d&#x27;, children:[] &#125;,&#123; val:&#x27;e&#x27;, children:[] &#125;] &#125;, &#123; val:&#x27;c&#x27;, children:[&#123; val:&#x27;f&#x27;, children:[] &#125;,&#123; val:&#x27;g&#x27;, children:[] &#125;] &#125;]&#125;//dfs:deep first searchconst dfs=(root)=&gt;&#123; console.log(root.val) root.children.forEach(dfs)&#125; 广度优先遍历广度优先遍历，先访问离根节点最近的节点 新建一个队列，把根节点入队 把队头出队，并访问 把对头的children 挨个入队 重复上面 2、3步骤知道队列为空 123456789101112// bfs: breadth first searchconst bfs=(root)=&gt;&#123; let queue=[root]; while(queue.length)&#123; const n=queue.shift(); console.log(n.val); n.children.forEach(child=&gt;&#123; queue.push(child) &#125;) &#125;&#125;bfs(tree) 二叉树 树中每个节点最多只能有两个子节点 在js中用Object 来模拟二叉树 123456789101112131415161718192021222324252627282930// bt:binary treeconst bt=&#123; val:1, left:&#123; val:4, left:&#123; val:2, left:null, right:null &#125;, right:&#123; val:5, left:null, right:null &#125; &#125;, right:&#123; val:3, left:&#123; val:6, left:null, right:null &#125;, right:&#123; val:7, left:null, right:null &#125; &#125;&#125; 二叉树的先序遍历算法口诀 访问根节点 访问根节点的左子树进行先序遍历 访问根节点的右子树进行先序遍历 12345678910111213141516171819// 递归版const preorder=(root)=&gt;&#123; if(!root) return console.log(root.val); preorder(root.left); preorder(root.right);&#125;// 非递归版：const preorder=(root)=&gt;&#123; if(!root) return let stack=[root]; while(stack.length)&#123; const n=stack.pop() console.log(n.val) if(n.right) stack.push(n.right) if(n.left) stack.push(n.left) &#125;&#125; 二叉树的中序遍历算法口诀 访问根节点的左子树进行中序遍历 访问根节点 对根节点的右子树进行中序遍历 123456789101112131415161718192021222324// 递归版本const inorder=(root)=&gt;&#123; if(!root)return inorder(root.left); console.log(root.val); inorder(root.right)&#125;inorder(bt)// 非递归版:将根节点所有左子树加入栈中,弹出栈顶原数并访问val,将指针指向右子树，右子树作为下一次循环的根节点const inorder=(root)=&gt;&#123; if(!root)return const stack=[]; let p=root; while (stack.length || p)&#123; while(p)&#123; stack.push(p) p=p.left &#125; const n=stack.pop(); console.log(n.val); p=n.right &#125;&#125; 二叉树的后序遍历算法口诀 对根节点的左子树进行后序遍历 对根节点的右子树进行后续遍历 访问根节点 1234567891011121314151617181920212223// 递归版本const postorder=(root)=&gt;&#123; if(!root)return postorder(root.left) postorder(root.right) console.log(root.val)&#125;// 非递归版:和前序遍历类似，然后输出顺序颠倒const postorder=(root)=&gt;&#123; if(!root) return const stack=[root]; const outputstack=[]; while(stack.length)&#123; const n=stack.pop(); outputstack.push(n) if(n.left) stack.push(n.left) if(n.right) stack.push(n.right) &#125; while(outputstack.length)&#123; const n=outputstack.pop() console.log(n.val) &#125;&#125; 题目自测 找到dom树的最深节点(可能多个)，并返回 12345678910function findDomDeepChild(node)&#123; if(!node.children || node.children.length===0)&#123; return 1 &#125; const max &#125;const root=document.querySelector(&#x27;body&#x27;)findDomDeepChild(root)","categories":[{"name":"算法","slug":"算法","permalink":"https://mandylucky.github.io/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"https://mandylucky.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"this","slug":"js/this","date":"2021-05-10T23:44:54.000Z","updated":"2023-06-27T03:33:17.754Z","comments":true,"path":"2021/05/11/js/this/","link":"","permalink":"https://mandylucky.github.io/2021/05/11/js/this/","excerpt":"","text":"概述this是一个特别的关键字，被自动定义在所在函数的作用域中。this提供了一种更优雅的方式隐式”传递“一个对象的引用。 关于this的误解 this指向自身(❌) this指向函数的词法作用域(❌) 那this到底是什么?this实际上是在函数被调用时发生的绑定，它指向什么完全取决于函数在哪里被调用 调用位置调用位置就是函数在代码中被调用的位置寻找调用位置：先分析调用栈，找到栈中第二个元素就是真正的调用位置 12345678910111213function baz()&#123; // 当前的调用栈是baz,因此调用位置在全局作用域中 bar()&#125;function bar()&#123; // 当前的调用栈是 baz-&gt;bar,因此当前调用位置在baz中 foo()&#125;function foo()&#123; // 当前调用栈是 baz-&gt;bar-&gt;foo,因此当前调用位置在bar中&#125;baz() 绑定规则先找到调用位置，然后判断需要应用下面哪一条规则 默认绑定独立函数调用，既不带任何修饰符的函数引用进行调用 使用默认绑定规则. 默认绑定在非严格模式下this指向全局变量，严格模式下this 会绑定到undefined 123456//非严格模式function foo()&#123; console.log(this.a)&#125;var a=2;foo() //2 12345678//严格模式function foo()&#123; &quot;use strict&quot; console.log(this.a)&#125;var a=2;foo() //undefined 隐式绑定由上下文对象调用，绑定到那个上下文对象 12345678function foo()&#123; console.log(this.a)&#125;var obj=&#123; a:2, foo:foo&#125;obj.foo()//2 对象属性引用链中，只有最后一层在调用位置中起作用 123456789101112function foo()&#123; console.log(this.a)&#125;var obj2=&#123; a:42, foo:foo&#125;var obj1=&#123; a:2, obj2:obj2&#125;obj1.obj2.foo() //42 foo 中的this 绑定到了obj2 隐式绑定函数，丢失绑定对象例子1： 12345678910function foo()&#123; console.log(this.a)&#125;var obj=&#123; a:2, foo:foo&#125;var bar=obj.foo;var a=&#x27;global a&#x27;bar()//&#x27;global a&#x27;，bar 不带任何修饰函数，因此应用了默认绑定规则 例子2： 12345678910111213function foo()&#123; console.log(this.a)&#125;function doFoo(fn)&#123; // fn是引用foo fn() //在这里调用，没有任何修饰符 走默认绑定规则&#125; var obj=&#123; a:2, foo:foo&#125;var a=&quot;global a&quot;doFoo(obj.foo) //&quot;global a&quot; 例子3： 1234567setTimeout(obj.foo,100) //&quot;global a&quot;//setTimeout函数伪代码 function setTimeout(fn,delay)&#123; fn() //在这里调用，没有任何修饰符 走默认绑定规则&#125; 参数传递其实就是一种隐式赋值，因此我们传递参数是函数时也会被隐式赋值。 显式绑定使用call()、apply()方法可以直接指定this的绑定对象，因此称为显式绑定 1234567function foo()&#123; console.log(this.a)&#125;var obj=&#123; a:2&#125;foo.call(obj) //2 显式绑定无法解决之前提到的丢失绑定的问题 硬绑定显式的强制绑定，称之为硬绑定12345function bind(fn,obj)&#123; return function()&#123; return fn.apply(obj,arguments) &#125;&#125; ES5中提供了内置方法 Function.prtotype.bind API 调用的 “上下文”一些内置方法提供了一个可选参数，被称之为上下文，作用和bind一样确保你的回调函数使用指定的this12345678function foo()&#123; console.log(el,this.id)&#125;var obj=&#123; id:&#x27;awesome&#x27;&#125;[1,2,3].forEach(foo,obj)//1 awesome 2 awesome 3 awesome new绑定1234567// new 源码实现function newFun(con,...args)&#123; var obj=new Object(); obj.__proto__=con.prototype const res=con.apply(obj,args) return res instanceof Object?res:obj&#125; 在new的源码实现中可以看到新对象会绑定构造函数的this上 优先级：new&gt;显式绑定&gt;隐式绑定&gt;默认绑定绑定例外 被忽略的this把null 或 undefined 作为this的绑定对象传入call 、apply 或者 bind ,这些值在调用时会被忽略，实际应用的是默认绑定规则 间接引用创建一个函数的”间接引用“ ，在这种情况下，调用这个函数会应用默认绑定规则。 12345678function foo()&#123; console.log(this.a)&#125;var a=2;var o=&#123;a:3,foo:foo&#125;var p=&#123;a:4&#125;o.foo() //3(p.foo=o.foo)() //2 赋值表达式 p.foo=o.foo的返回值是目标函数的引用，因此相当于调用的是foo()，所以会走默认绑定 软绑定硬绑定大大降低了函数的灵活性，使用硬绑定之后无法使用使用隐式绑定或者显示绑定来修改this// TODO 待补充… 箭头函数（this词法）箭头函数不使用this的四种绑定规则，箭头函数是没有this，是根据外层作用域来决定this。所以箭头函数的绑定无法被修改 题目自测，你真的懂了吗？1234567891011121314var a = 1;function fn()&#123; &quot;use strict&quot; console.log(a) var a = 2; function fb()&#123; console.log(a); console.log(this,&#x27;==this&#x27;) console.log(this.a); &#125; return fb;&#125;fn.call(&#123;a: 3 &#125;)(); 点击查看答案及解析 打印结果：undefined、2、1 undefined解析： 变量提升，a 提升到函数作用域顶部 2解析： 闭包 1解析： fn.call({a: 3 }) 返回了 fb引用 ，fn.call({a: 3 })() 等价于 fb()，因为默认绑定在非严格模式下this指向全局变量，严格模式下this 会绑定到undefined，所以非严格模式下 结果为1，严格模式下 TypeError 1234567891011121314151617let num=20;let obj=&#123; num:40, init:function()&#123; console.log(this.num) function p()&#123; console.log(this.num) &#125; p.prototype.name=function()&#123; console.log(this.num) &#125; return p &#125;&#125; let p=obj.init() p()new p() 点击查看答案及解析 let p=obj.init()解析 执行console.log(this.num) this指向obj 所以返回结果为 40 p()解析 执行let p=obj.init()返回p 函数引用,执行p() 等价于直接执行 init内的p函数且使用默认规则this 指向window， let num=20 ；声明全局变量 num ，但是 let 声明的变量不属于顶层对象的属性，因此 num 为undefined new p()解析 首先我们知道 构造函数中的this 指向实例对象，实例对象 原型链中没有 num ，因此 p函数执行时 this.num 会打印 undefined ,原型方法 name 未被执行 其他关联知识点顶层对象 vs 全局变量 顶层对象，在浏览器环境指的是window对象，在 Node 指的是global对象。顶层对象的属性与全局变量挂钩，被认为是 JavaScript 语言最大的设计败笔之一。ES6 为了改变这一点，一方面规定，为了保持兼容性，var命令和function命令声明的全局变量，依旧是顶层对象的属性；另一方面规定，let命令、const命令、class命令声明的全局变量，不属于顶层对象的属性。也就是说，从 ES6 开始，全局变量将逐步与顶层对象的属性脱钩。","categories":[{"name":"js","slug":"js","permalink":"https://mandylucky.github.io/categories/js/"}],"tags":[{"name":"你不知道的js读书笔记","slug":"你不知道的js读书笔记","permalink":"https://mandylucky.github.io/tags/%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84js%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"},{"name":"js基础","slug":"js基础","permalink":"https://mandylucky.github.io/tags/js%E5%9F%BA%E7%A1%80/"}]},{"title":"时间空间复杂度","slug":"算法/时间空间复杂度","date":"2021-05-10T03:49:01.000Z","updated":"2023-06-27T03:33:17.755Z","comments":true,"path":"2021/05/10/算法/时间空间复杂度/","link":"","permalink":"https://mandylucky.github.io/2021/05/10/%E7%AE%97%E6%B3%95/%E6%97%B6%E9%97%B4%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6/","excerpt":"","text":"时间复杂度 算法的时间复杂度是指算法需要消耗的时间资源。复杂度用函数 大O表示，它定性描述该算法的运行时间。 O(1)&lt;O(logN)&lt;O(n)时间复杂度O(1):代码只被执行了一次 12let i=0;i+=1; 时间复杂度O(n):for循环内的代码被执行了n次 123for(let i=0;i&lt;n;i++)&#123; console.log(i)&#125; 时间复杂度O(1)+O(n)=O(n):当n足够大的时候O(1)可以忽略 12345let i=0;i+=1;for(let j=0;j&lt;n;j++)&#123; console.log(j)&#125; *时间复杂度O(n)O(n)=O(n^2) 12345for(let i=0;i&lt;n;i++)&#123; for(let j=0;j&lt;n;j++)&#123; console.log(i,j) &#125;&#125; 时间复杂度 O(logN) 12345let i=0;while(i&lt;n)&#123; console.log(i) i*=2&#125; 数学知识补充：如果ax=N（a&gt;0，且a≠1）【a的x次方等于N】，那么数x叫做以a为底N的对数，记作x=logaN，读作以a为底N的对数，其中a叫做对数的底数，N叫做真数。 名词解释【定性描述】不会具体的体现多少秒，只是体现一个大致的趋势 空间复杂度 算法的空间复杂度是指算法需要消耗的空间资源。复杂度用函数 大O表示，它定性描述该算法的运行过程中占用空间的大小。 空间复杂度O(1):只声明了单个遍历，单个遍历所占用的内存为1 12let i=0;i+=1; 空间复杂度 O(n):数组中添加了n个值，占用了n个内存单元 1234const list=[];for(let i=0;i&lt;n;i++)&#123; list.push(i)&#125; 空间复杂度：二维数组存储了n^2 个变量 1234567const matrix=[]for(let i=0;i&lt;n;i++)&#123; matrix.push([]) for(let j=0;j&lt;n;j++)&#123; matrix[i].push(j) &#125;&#125;","categories":[{"name":"算法","slug":"算法","permalink":"https://mandylucky.github.io/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"算法基础","slug":"算法基础","permalink":"https://mandylucky.github.io/tags/%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80/"}]},{"title":"算法总结","slug":"算法/算法总结","date":"2021-05-10T03:49:01.000Z","updated":"2023-06-27T03:33:17.756Z","comments":true,"path":"2021/05/10/算法/算法总结/","link":"","permalink":"https://mandylucky.github.io/2021/05/10/%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/","excerpt":"","text":"数据结构决定了，数据存储的空间和时间效率问题，算法会提高数据的处理效率 前端常见的数据结构简单数据结构1.有序数据结构：栈、队列、链表 【有序数据结构省空间，存储空间小】2.无序数据结构：集合、字典、散列表【无序数据结构省时间，读取快】 复杂数据结构 树、堆、图 常见算法 递归 排序 枚举 递归、循环 二叉树：前/中/后 序遍历（栈）、深度/广度遍历（队列）实现方式：递归、循环 查找、排序查找：二分查找、哈希表查找、二叉排序树查找排序：插入排序、冒泡排序、归并排序、快速排序","categories":[{"name":"算法","slug":"算法","permalink":"https://mandylucky.github.io/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"算法基础","slug":"算法基础","permalink":"https://mandylucky.github.io/tags/%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80/"}]},{"title":"作用域和闭包","slug":"js/作用域和闭包","date":"2021-05-09T23:44:54.000Z","updated":"2023-06-27T03:33:17.754Z","comments":true,"path":"2021/05/10/js/作用域和闭包/","link":"","permalink":"https://mandylucky.github.io/2021/05/10/js/%E4%BD%9C%E7%94%A8%E5%9F%9F%E5%92%8C%E9%97%AD%E5%8C%85/","excerpt":"","text":"作用域是什么前置知识——编译原理js的编译发生在执行前几微妙，所有代码在执行之前都要进行编译。在编译阶段会预先确定变量、函数定义的位置，确保在执行过程中能快速的找到它。 编译步骤: 词法分析: 将由字符组成的字符串分解成有意义的代码块（词法单元)eg:var a=2; 将被分解成: var、a 、= 、2 、; 语法分析: 将词法单元流转成抽象语法树(AST) 代码生成: 将AST转成可执行代码的过程叫做代码生成 思考个问题 var a=2;程序处理的过程是什么样子的? 解析器会将这段程序分解成词法单元 将词法单元解析成AST 编译器开始进行代码生成3.1 编译器遇到 var a,编译器会询问作用域是否已经存在该名称的变量，存在则忽略，不存在则在当前作用域中声明一个新变量，并命名为a3.2 编译器为引擎生成运行时所需的代码 运行时，引擎在作用域中查找该变量，找到则赋值，没找到则抛出异常 编译器术语 —— LHS、RHS变量查找会用到 LHS 查询和 RHS查询LHS查询：目的为变量赋值RHS查询：目的为获取变量的值 RHS 引用失败会抛出ReferenceError，LHS在非严格模式下引用失败会创建全局作用域，严格模式下抛出ReferenceError 嵌套作用域当一个块级作用域嵌套在另一个函数作用域中时，就发生了作用域嵌套。因此，当前作用域无法找到某个变量时，引擎就会在外层嵌套的作用域中继续寻找。直到找到该变量或者抵达最外层作用域为止 作用域嵌套产生作用域链 词法作用域作用域工作模式分为：词法作用域、动态作用域javaScript 采用词法作用域 词法阶段词法作用域：定义在词法阶段的作用域，既写代码时将变量写在哪里来决定的，因此当词法分析器处理代码时会保持作用域不变。 查找12345678function foo(a)&#123; var b=a*2; function bar(c)&#123; console.log(a,b,c) &#125; bar(b*3)&#125;foo(2) 作用域查找始终从运行时所处的内部作用域开始查找，逐级向上，直到遇到第一个匹配的标识符 或者 到达全局作用域为止 无论函数在哪里被调用，也无论它如何被调用，它的词法作用域都只由函数被声明时所处的位置决定。 欺骗词法欺骗词法：运行时修改作用域 eval语法：eval(string)作用：eval() 函数会将传入的字符串当做 JavaScript 代码进行执行。 12345function foo(str,a)&#123; eval(str)//欺骗 console.log(a,b)&#125;foo(&quot;var b=3&quot;,1) 上述代码中var b=3会被当做本来就写在哪里一样，eval中所执行的代码如果包含声明的话，将对eval 所在的词法作用域进行修改（严格模式无法修改） with语法：123with (expression) &#123; statement&#125; 作用:通常被用于重复引用统一对象中多个属性的快捷方式 1234567891011121314var obj=&#123;a:1,b:2,c:3&#125;with(obj)&#123; a=2; b=3; c=4&#125;//等价于obj.a=2;obj.b=3;obj.c=4;with(obj)&#123; e=9;//e被泄露到全局作用上了&#125; 会创建全新的词法作用域，严格模式下with 被完全禁止 性能问题javaScript 引擎会在编译阶段进行性能优化，有些优化依赖于根据词法作用域进行静态分析，预先确定变量、函数位置，才能在执行过程中快速找到标识符。eval/with ，修改了词法作用域，使优化变得没有意义，大量使用运行会变慢 函数作用域和块作用域函数作用域函数内部的变量/函数，函数外部无法访问 函数声明 vs 函数表达式 区分：function 是声明中的第一个词则是函数声明，否则就是函数表达式 区别： 函数声明的标识符被绑定在所在作用域、函数表达式则被绑定在函数表达式自身的函数中 函数表达式可以匿名，函数声明不可以 匿名函数缺点与最佳实践 栈追踪不会显示出有意义的函数名，使调试困难 没有函数名只能通过arguments.callee 引用自身（方法已经弃用） 可读性差 始终给表达式命名是最佳实践 123setTimeout(function Name()&#123;&#125;) 立即执行函数表达式两种写法 (function(){}()) (function(){})() 例子 1234567891011(function IIFE (global)&#123; console.log(global)&#125;)(window)(function IIFE (def)&#123; def(window)&#125;)( function def(global)&#123; console.log(&#x27;xxx&#x27;) &#125;) 块作用域with、try/catch 会创建块作用域 let ES6引入let关键字，提供变量声明方式，let关键字可以将变量绑定到所在作用域（通常是{…}内） let声明不会在块作用域中进行提升 let与垃圾回收 12345678function process(data)&#123;&#125;var someData=&#123;&#125;process(someData)var btn=document.getElementById(&#x27;xxx&#x27;)btn.addEventListener(&#x27;click&#x27;,function click(evt)&#123; console.log(&#x27;xxx&#x27;)&#125;) 上述代码 因为click函数形成了闭包，所以外部作用域中的process 执行完也不会被销毁someData 使用块级作用域优化 123456789101112function process(data)&#123;&#125;//定义在块中 执行完可以被正常销毁&#123;let someData=&#123;&#125; process(someData)&#125;var btn=document.getElementById(&#x27;xxx&#x27;)var btn=document.getElementById(&#x27;xxx&#x27;)btn.addEventListener(&#x27;click&#x27;,function click(evt)&#123; console.log(&#x27;xxx&#x27;)&#125;) let 循环 123for(let i=0;i&lt;10;i++)&#123; console.log(i)&#125; 将let 绑定到循环的每一次迭代中 constES6引入const ，同样可以用来创建块作用域变量，但其值为常量，试图修改会报错 提升 变量和函数声明从它们在代码中出现的位置，被 “移动” 到了所在作用域的最上面，这个过程叫作 “提升” var a=2; js将其看成两个步骤：先声明、后赋值。只有声明会被提升，赋值会留在原地 函数声明会被提升，但函数表达式不会被提升 函数优先函数声明和变量声明同名时候，函数声明会提升到普通变量之前，同名的函数声明则会被后面的覆盖 tips:不要在块内声明函数 123456foo()//TypeErrorif(true)&#123; function foo()&#123;console.log(&#x27;a&#x27;)&#125;&#125;else&#123; function foo()&#123;console.log(&#x27;b&#x27;)&#125;&#125; 一个普通块内部的函数通常会被提升到所在作用域的顶部 作用域闭包 闭包是指有权访问另外一个函数作用域中变量的函数 ——JavaScript高级程序设计 当函数可以记住并访问所在词法作用域，即使函数是在当前词法作用域之外执行，这就就产生了闭包 ——你不知道的JavaScript 123456789function foo()&#123; var a=2; function bar()&#123; console.log(a) &#125; return bar&#125;var baz=foo();baz();//2 这就是闭包效果 闭包应用 只要用来回调函数，实际上就是在使用闭包（定时器、事件监听器…） 循环和闭包 123456789101112131415161718for(var i=1;i&lt;5;i++)&#123; setTimeOut(function timer()&#123; console.log(i) //全部输出6 &#125;,i*1000)&#125;for(var j=0;j&lt;5;j++)&#123; (function(k)&#123; setTimeOut(function timer()&#123; console.log(k) &#125;,k*1000) &#125;)(j)&#125;for(let j=0;j&lt;5;j++)&#123; setTimeOut(function timer()&#123; console.log(j) &#125;,k*1000)&#125; 题目自测，你真的懂了吗？1234567891011var a=1;function fn()&#123; console.log(a,&#x27;---a1&#x27;) var a=2; function fb()&#123; console.log(a,&#x27;---a2&#x27;) &#125; return fb&#125;const resFunc=fn()resFunc() 点击查看答案及解析 第一个a打印结果为：undefined、第二个a打印结果为：2 第一个a 打印结果解析: 第一个a 打印结果为undefined ,是因为提升，在ES5 只有全局作用域和函数作用域，提升会把变量声明移动到当前作用域的顶部，var a=2; 中 var a 声明会被移动到当前函数作用域的顶部，var a 之后访问a ，其值为undefined 第二个a 打印结果解析: 第二个a 打印结果为2，是因为闭包,始终访问所在的词法作用域，在作用域链的前端开始寻找变量a,如果找到就返回,找不到报错ReferenceError，在外层作用域中找到了a 其值为2","categories":[{"name":"js","slug":"js","permalink":"https://mandylucky.github.io/categories/js/"}],"tags":[{"name":"你不知道的js读书笔记","slug":"你不知道的js读书笔记","permalink":"https://mandylucky.github.io/tags/%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84js%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"},{"name":"js基础","slug":"js基础","permalink":"https://mandylucky.github.io/tags/js%E5%9F%BA%E7%A1%80/"}]},{"title":"Vue nextTick原理","slug":"js/vue/renderMixin","date":"2021-05-09T03:30:25.000Z","updated":"2023-06-27T03:33:17.754Z","comments":true,"path":"2021/05/09/js/vue/renderMixin/","link":"","permalink":"https://mandylucky.github.io/2021/05/09/js/vue/renderMixin/","excerpt":"","text":"概述生命周期相关的实例方法有4个：vm.$mount、vm.$forceUpdate 、vm.$destroy、vm.$nextTick，本文主要讲述 vm.$nextTick。 使用&amp;作用语法：vm.$nextTick( [callback] ) 作用：将回调延迟到下次 DOM 更新循环之后执行。在修改数据之后立即使用它，然后等待 DOM 更新。 示例： 12345//回调函数写法this.$nextTick(function()&#123;&#125;)//Promise写法this.$nextTick().then(function()&#123;&#125;) “下一个DOM 更新循环”是什么意思？？？ 当状态变化时，watcher 会得到通知，然后触发虚拟DOM的渲染流程。watcher 触发渲染这个操作是异步的。 Vue.js 中有一个队列，每当需要渲染时，会将watcher 推送到这个队列中，在下一次事件循环中再让watcher 触发渲染的流程 数据的变化到 DOM 的重新渲染是一个异步过程 1.为什么Vue.js 使用异步更新队列 变化侦测的通知发送到组件，组件内用到的所有状态的变化都会通知到同一个watcher,然后对整个组件的新旧虚拟DOM进行对比并更改DOM。如果同一轮事件循环中有两个数据发生了变化，那么组件的watcher 会收到两份通知，从而进行两次渲染？当然不是！ vue为了解决上述问题，Vue的实现方式是将收到通知的watcher实例 添加到队列中缓存起来，并且在添加到队列之前检查是否已经存在相同watcher,只有不存在时才会将watcher实例添加到队列中。 然后在下一次事件循环中，Vue.js 会让队列中的Watcher 触发渲染流程并清空队列。这样就可以保证同一事件循环中，两个数据变化,watcher 最终也只执行一次渲染流程。 2.什么是事件循环javaScript 是单线程非阻塞的脚本语言，这就意味着javascript 代码在执行的时候有一个主线程来处理所有任务，非阻塞是指处理异步任务时，主线程会挂起这个任务，当异步任务处理完毕，将这个事件加入事件队列。事件队列。 异步任务有两种类型：微任务（mincrotask)、宏任务(macrotask)。不同类型的任务会被分配到不同的任务队列中。 微任务：Promise.then、MutationObserve 宏任务：setTimeout、setInterval、setImmediate、PostMessage 当执行栈中所有任务都执行完毕后，会去检查微任务队列是否有事件存在，如果存在，则会依次执行并移除微任务队列中事件对应的回调，直到为空。 然后去宏任务队列中取出一个任务放入执行栈，当执行栈中所有任务都执行完毕后，检查微任务队列中是否有事件存在，不断循环这个过程 ，这个循环就叫做事件循环 3.什么是执行栈当我们执行一段可执行代码时，会生成对应的执行上线文，执行上下文会被添加到一个栈中，这个栈就是执行栈。 回到前面的问题 ”下一个DOM 更新循环“的意思其实是下一次微任务执行时更新DOM。vm.$nextTick 其实是将回调添加到微任务中，如果语法不支持则降级成宏任务 因此，使用vm.$nextTick来获取更新后的DOM，则需要注意顺序问题。因为不论是更新DOM的回调，还是vm.$nextTick 注册的回调，都是向微任务队列中添加任务，所以哪个任务先添加到队列中，就先执行哪个任务 更新DOM的回调也是使用vm.$nextTick 来注册到微任务队列中的 如果想在vm.$nextTick 中获取更新后的DOM，则一定要在更新数据的后面使用vm.$nextTick 注册回调。如果先使用vm.$nextTick 注册回调再修改数据 是获取不到更新后的DOM的。因为在微任务队列中先执行vm.$nextTick 回调，后执行DOM更新。 在事件循环中，当执行栈中同步任务执行完之后，会先执行并清空微任务后 ，才会从宏任务队列中取出一个事件,执行下一轮。 所以添加到微任务队列中的任务执行时机优先于宏任务队列中的任务 12345678910new Vue(&#123; methods:&#123; example:function()&#123; setTimeout(()=&gt;&#123; //dom更新了 &#125;,0) this.message=&#x27;changed&#x27; &#125; &#125;&#125;) setTimeout 是宏任务，宏任务比微任务执行晚，所以即便是先注册也是先执行更新DOM，后执行setTimeout 回调 实现原理1234import &#123;nextTick&#125; from &#x27;./util/index&#x27;Vue.prototype.$nextTick=function(fn)&#123; return nextTick(fn,this)&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081const callbacks=[];let pending=false;//用于标记是否已经向任务队列中添加一个任务function flushCallbacks()&#123; pending=false const copies=callbacks.slice(0); callbacks.length=0; for(let i=0;i&lt;copies.length;i++)&#123; copies[i]() &#125;&#125;let microTimerFunc; let macroTimerFunc=;let useMacroTask=false;// 宏任务方法定义：降级顺序 setImmediate——&gt;MessageChannel——&gt;SetTimeoutif(typeof setImmediate !==&#x27;undefined&#x27; &amp;&amp; isNative(setImmediate))&#123; macroTimerFunc=()=&gt;&#123; setImmediate(flushCallbacks) &#125;&#125;else if(type of MessageChannel !==&#x27;undefined&#x27; &amp;&amp; (isNative(MessageChannel) || MessageChannel.toString ===&#x27;[object MessageChannelConstructor]&#x27; ))&#123; const channel=new MessageChannel(); const port=channel.port2 channel.port1.onmessage=flushCallbacks macroTimerFunc=()=&gt;&#123; port.postMessage(1) &#125;&#125;else&#123; macroTimerFunc=()=&gt;&#123; setTimout(flushCallbacks,0) &#125;&#125;//微任务方法定义：不支持promise 降级为宏任务if(typeof Promise !==&#x27;undefined&#x27; &amp;&amp; isNative(Promise))&#123; const p=Promise.resolve(); microTimerFunc=()=&gt;&#123; p.then(flushCallbacks) //将flushCallbacks 添加到微任务队列中 &#125;&#125;else&#123; microTimerFunc=macroTimerFunc&#125;// withMacroTask 的作用是给回调函数做一层包装，保证在回调函数执行过程中，如果修改了数据，那么更新DOM的操作会被推倒宏任务队列中。【更新DOM的执行事件会晚于回调函数的执行事件】export function withMacroTask(fn)&#123; return fn.withFask || (fn._withTask=function()&#123; useMacroTask=true; const fn.apply(null,arguments) useMacroTask=false return res &#125;)&#125;//没有提供回调且支持promise 时候返回promiseexport function nextTick(cb,ctx)&#123; let _resolve callbacks.push(()=&gt;&#123; if(cb)&#123; cb.call(ctx) &#125;else if(_resolve)&#123; _resolve(ctx) &#125; &#125;) if(!pending)&#123; pending=true if(useMacroTask)&#123; macroTimerFunc() &#125;else&#123; microTimerFunc() &#125; &#125; //promise if(!cb &amp;&amp; typeof Promise !==&#x27;undefined&#x27;)&#123; return new Promise(resolve=&gt;&#123; _resolve=resolve &#125;) &#125;&#125;//测试 nextTick(function()&#123; console.log(this.name) //mandyer&#125;,&#123; name:&#x27;mandyer&#x27;&#125;) nextTick内部注册和执行流程注册流程：首先nextTick 被调用时，会将回调函数添加到callbacks 中，如果此时是本轮事件循环第一次使用nextTick,那么需要向任务队列中添加队列（Promise.then 作用是将任务添加到微任务队列中）。如果不是本轮事件循环中第一次调用nextTick，就说明任务队列已经已经添加了执行回调列表的任务，就不需要重复添加了。 执行流程：依次执行callbacks 中所有的回调 总结： 使用nextTick的作用是让回调再下一次DOM更新之后执行。 Vue.js 是怎么作用让回调函数在DOM更新后执行的呢？数据更新到视图渲染是一个异步的过程，我们手动调用nextTick 和 触发Dom更新都会调用nextTick，nextTick会将回调函数添加到callbacks 队列中，当callbacks 被执行时 先加入的会先执行，后加入的后执行 ，所以在更新dom 回调 后面加入callbacks 的回调可以获取到更新后的DOM节点 callbacks 如何执行？nextTick 会将执行callbacks 的任务添到任务队列中，且一次事件循环中只添加一次 s=>start: nextTick e=>end: 结束 op1=>operation: 将回调添加到callbacks中 c1=>condition: 本轮事件循环中第一次使用nextTick? op2=>operation: 向任务队列中添加任务 s->op1->c1(yes)->op2->e s->op1->c1(no)->e{\"scale\":1,\"line-width\":2,\"line-length\":50,\"text-margin\":10,\"font-size\":12} var code = document.getElementById(\"flowchart-0-code\").value; var options = JSON.parse(decodeURIComponent(document.getElementById(\"flowchart-0-options\").value)); var diagram = flowchart.parse(code); diagram.drawSVG(\"flowchart-0\", options);op1=>operation: 任务被执行 op2=>operation: 依次执行callbacks 中的所有回调 op3=>operation: 清空callbacks op1->op2->op3{\"scale\":1,\"line-width\":2,\"line-length\":50,\"text-margin\":10,\"font-size\":12} var code = document.getElementById(\"flowchart-1-code\").value; var options = JSON.parse(decodeURIComponent(document.getElementById(\"flowchart-1-options\").value)); var diagram = flowchart.parse(code); diagram.drawSVG(\"flowchart-1\", options);","categories":[{"name":"Vue","slug":"Vue","permalink":"https://mandylucky.github.io/categories/Vue/"}],"tags":[{"name":"Vue实例方法","slug":"Vue实例方法","permalink":"https://mandylucky.github.io/tags/Vue%E5%AE%9E%E4%BE%8B%E6%96%B9%E6%B3%95/"},{"name":"Vue深入浅出读书笔记","slug":"Vue深入浅出读书笔记","permalink":"https://mandylucky.github.io/tags/Vue%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"}]},{"title":"生命周期相关的实例方法 之 vm.$forceUpdate 、vm.$destroy","slug":"js/vue/lifecycleMixin","date":"2021-05-09T03:29:27.000Z","updated":"2023-06-27T03:33:17.754Z","comments":true,"path":"2021/05/09/js/vue/lifecycleMixin/","link":"","permalink":"https://mandylucky.github.io/2021/05/09/js/vue/lifecycleMixin/","excerpt":"","text":"概述生命周期相关的实例方法有4个：vm.$mount、vm.$forceUpdate 、vm.$destroy、vm.$nextTick 本文主要讲述 vm.$forceUpdate 、vm.$destroy,这两个方法从lifecycleMixin中挂载到Vue构造函数的prototype 属性上 1234export function lifecycleMixin(Vue)&#123; Vue.prototype.$forceUpdate=function()&#123;&#125; Vue.prototype.$destroy=function()&#123;&#125;&#125; vm.$forceUpdate使用说明vm.$forceUpdate 的作用是强制Vue实例重新渲染。 组件就是Vue.js实例，vm.$forceUpdate 仅仅影响实例本身以及插入插槽内容的子组件，而不是所有组件 实现原理执行watcher的update方法，就可以使Vue.js实例重新渲染。 123456Vue.prototype.$forceUpdate=function()&#123; const vm=this; if(vm._watcher)&#123; vm._watcher.update() &#125;&#125; vm._watcher是Vue.js实例的watcher,每当组件内依赖的数据发生变化时，都会自动触发Vue.js实例中_watcher的update 总结：强制更新的原理就是调用vue实例的watcher 的update方法 vm.$destroy使用说明vm.$destroy 的作用是完全销毁一个实例，它会清理该实例与其他实例的连接，并解绑全部的指令及监听器，同时会触发beforeDestroy 和 destroyed 的钩子函数 实现原理销毁实例逻辑:(0)开始清理前 12345678Vue.prototype.$destroy=function()&#123; const vm=this; if(vm._isBeginDestroyed)&#123; return &#125; callHook(vm,&#x27;beforeDestroy&#x27;) vm._isBeginDestroyed=true&#125; （1）清理当前组件与父组件之间的链接操作：将当前组件实例从父组件实例的$children属性中删除即可。 12345678910111213const parent=vm.$parentif(parent &amp;&amp; !parent._isBeginDestroyed &amp;&amp; !vm.$options.abstract)&#123; remove(parent.$children,vm)&#125;function remove(arr,item)&#123; if(arr.length)&#123; const index=arr.indexOf(item); if(index&gt;-1)&#123; array.splice(index,1) &#125; &#125;&#125; remove函数不是使用循环遍历的方式，而是下标结合splice 方法将元素从数组中删除 【优雅技巧get】 （2）移除watcher 实例watcher 状态会收集依赖(watcher)，当状态变化时通知依赖。当Vue.js实例被销毁时，将watcher 从Dep列表中移除 123if(vm._watcher)&#123; vm._watcher.teardown()&#125; watcher 的teardown 方法的作用是从所有依赖列表中将自己移除。【此时移除的只是vue实例上的watcher,还有用户自定义watcher 未被移除】 Vue2.0开始，变化侦测的粒度调整为中等粒度，只会发送通知到组件级别，然后组件使用虚拟DOM进行渲染（组件就是Vue实例） Vue.js 实例上，有一个watcher 就是vm._watcher 它会监听这个组件中用到的所有状态，将这个组件内用到的所有状态的依赖列表都会收集到vm._watcher 中。当状态发生变化时，会通知vm._watcher ，然后这个watcher 再调用虚拟DOM进行重新渲染 用户自定义watcher移除用户自定义watcher 同样也是使用teardown方法 每当创建watcher 实例时，都会将watcher 实例添加到vm._watchers中 12345export default class Watcher&#123; constructor(vm,exOrFn,cb)&#123; vm._watchers.push(this) &#125;&#125; 因此用户创建的watcher 都在vm._watcher中，当移除的时候遍历数组调用watcher的teardown方法即可 1234let i=vm.watchers.lengthwhile(i--)&#123; vm._watchers[i].teardown()&#125; (3)Vue实例添加_isDestroyed属性表示Vue实例已被销毁 1vm._isDestroyed=true (4)指令解绑vm.$destroy 执行时，Vue.js不会将已经渲染到页面中的DOM节点移除，但会将模板中的所有指令解绑 1vm.__patch__(vm._vnode,null) (5)触发destroyed 构造函数 1callHook(vm,&#x27;destroyed&#x27;) (6)移除实例上的所有事件监听器vm.$off() 完整代码 12345678910111213141516171819202122232425262728Vue.prototype.$destroy=function()&#123; const vm=this; if(vm._isBeginDestroyed)&#123; return &#125; callHook(vm,&#x27;beforeDestroy&#x27;) vm._isBeginDestroyed=true // 删除自己与父级之间的链接 const parent=vm.$parent if(parent &amp;&amp; !parent._isBeginDestroyed &amp;&amp; !vm.$options.abstract)&#123; remove(parent.$children,vm) &#125; // 从watcher 监听的所有状态的依赖列表中移除watcher if(vm._watcher)&#123; vm._watcher.teardown() &#125; let i=vm.watchers.length while(i--)&#123; vm._watchers[i].teardown() &#125; vm._isDestroyed=true // 在vnode 树上触发destroy构造函数解绑指令 vm.__patch__(vm._vnode,null) //触发destroyed 构造函数 callHook(vm,&#x27;destroyed&#x27;) //移除所有的事件监听器 vm.$off()&#125;","categories":[{"name":"Vue","slug":"Vue","permalink":"https://mandylucky.github.io/categories/Vue/"}],"tags":[{"name":"Vue实例方法","slug":"Vue实例方法","permalink":"https://mandylucky.github.io/tags/Vue%E5%AE%9E%E4%BE%8B%E6%96%B9%E6%B3%95/"},{"name":"Vue深入浅出读书笔记","slug":"Vue深入浅出读书笔记","permalink":"https://mandylucky.github.io/tags/Vue%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"}]},{"title":"数据相关的实例方法","slug":"js/vue/stateMixin","date":"2021-05-07T08:41:39.000Z","updated":"2023-06-27T03:33:17.754Z","comments":true,"path":"2021/05/07/js/vue/stateMixin/","link":"","permalink":"https://mandylucky.github.io/2021/05/07/js/vue/stateMixin/","excerpt":"","text":"vm.$watchvm.$setvm.$delete 概述数据相关的实例方法有3个：vm.$watch、vm.$set、vm.$delete,他们是在stateMixin 中挂载到Vue原型中的 Vue大致实现如下： 123456import &#123;stateMixin&#125; from &#x27;./xxx&#x27;function Vue(options)&#123; //.... stateMixin(Vue) //...&#125; 123456import &#123;set,del&#125; from &#x27;../observer/index&#x27;;export function stateMixin(Vue)&#123; Vue.prototype.$set=set; Vue.prototype.$delete=del; Vue.prototype.$watch=function(expOrFn,cb,options)&#123;&#125;&#125; 下面将详细介绍 vm.$watch、vm.$set、vm.$delete 实现原理 vm.$watch(expOrFn,callback,[options])使用说明用于观察一个表达式或者computed函数在Vue.js实例上的变化，变化后触发回调传入new value 和 old value。第一个参数如果是表达式只接受以点分隔eg:a.b.c,如果复杂的表达式，可以用函数代替表达式。 参数说明： {string | Function} expOrFn{Function | Object} callback{Object} [options] deep | immediate deep:为了发现对象内部值的变化,deep:trueimmediate:立即触发回调，immediate:true 返回值：{Function} unwatch 示例: 1234vm.$watch(&#x27;a.b.c&#x27;,function(newVal,oldVal)&#123; &#125;) 实现原理TODO 待补充… vm.$set(target,key,value)使用说明在对象上设置一个属性，如果object 是响应式的，保证属性被创建后也是响应式的，并且触发视图更新。该方法用于解决Vue.js无法监听object添加新属性的问题 参数说明： {Object | Array} target{string | number} key{any} value 返回值：{Function} unwatch 示例: 12let obj=&#123;a:&#x27;a&#x27;&#125;this.$set(obj,&#x27;key&#x27;,&#x27;val&#x27;) 实现原理1234567891011121314151617181920212223242526export function set(target,key,value)&#123; //情况一：数组 if(Array.isArray(target) &amp;&amp; isValidArrayIndex(key))&#123; trget.length=Max.max(target.length,key); target.splice(key,1,value) return value &#125; //情况二：已存在属性 if(target.hasOwnProperty(key))&#123; target[key]=value return value &#125; //情况三：新增属性 const ob=target.__ob__ //__ob__属性用于判断是否是响应式对象 if(target._isVue || (ob&amp;&amp;ob.vmCount))&#123; //警告不可以是 vue实例 或者 根数据对象 return value &#125; if(!ob)&#123; target[key]=value return value &#125; definReactive(ob.value,key,value)//使用definReactive将新增属性转为响应式数据 ob.dep.notify() //向target的依赖触发变化通知 return val&#125; 总结：数组类型直接用spice 方法,对象类型分两种情况(1)已存在属性，直接修改属性值 (2)新增属性 ，分为两种情况 对象不是响应式数据 直接修改属性值，对象是响应式数据 使用definReactive 将新增属性换为响应式数据，然后调用dep.notify通知依赖vm.$delete(target,key)使用说明vm.$delete 方法用来删除数据中的某个属性。如果对象是响应式的要触发视图更新，该方法用于解决Vue.js无法监听object删除新属性的问题 参数说明：{Object|Array} target{string | number} key/index 示例: 实现原理123456789101112131415161718192021export function del(target,key)&#123; //数组类型 if(Array.isArray(target) &amp;&amp; isValidArrayIndex(key))&#123; target.splice(key,1) return &#125; //对象类型 if(target._isVue || (ob &amp;&amp; ob.vmCount))&#123; //警告对象不可以是vue实例，也不可以是根数据 return &#125; if(!hasOwn(target,key))&#123;//key 不存在直接return return &#125; const ob=target.__ob__ delete target[key] if(!ob)&#123; //如果不是相应数据无需通知变化 return &#125; ob.dep.notify()&#125; 总结：数组类型直接用spice 方法，对象类型 分为两种情况(1)不是响应式数据 只做删除操作 (2)是响应式数据删除后触发dep.notify 进行通知,异常处理有两个，（1）target 不可以为跟数据或者vue实例（2）对象中不存在目标key 直接return","categories":[{"name":"Vue","slug":"Vue","permalink":"https://mandylucky.github.io/categories/Vue/"}],"tags":[{"name":"Vue实例方法","slug":"Vue实例方法","permalink":"https://mandylucky.github.io/tags/Vue%E5%AE%9E%E4%BE%8B%E6%96%B9%E6%B3%95/"},{"name":"Vue深入浅出读书笔记","slug":"Vue深入浅出读书笔记","permalink":"https://mandylucky.github.io/tags/Vue%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"}]},{"title":"事件相关的实例方法","slug":"js/vue/eventMixin","date":"2021-05-07T08:18:36.000Z","updated":"2023-06-27T03:33:17.754Z","comments":true,"path":"2021/05/07/js/vue/eventMixin/","link":"","permalink":"https://mandylucky.github.io/2021/05/07/js/vue/eventMixin/","excerpt":"","text":"vm.$onvm.$emitvm.$offvm.$once 概述与事件相关的实例方法有4个，分别是:vm.$on 、 vm.$once 、vm.$off 和 vm.$emit,这四个方法是在eventsMixin中被挂载到Vue构造函数的原型中的。 Vue大致实现如下： 123456import &#123;eventsMixin&#125; from &#x27;./events&#x27;function Vue(options)&#123; //.... eventsMixin(Vue) //...&#125; 1234567891011121314export function eventsMixin(Vue)&#123; Vue.prototype.$on=function(event,fn)&#123; //todo something &#125; Vue.prototype.$emit=function(event,fn)&#123; //todo something &#125; Vue.prototype.$once=function(event,fn)&#123; //todo something &#125; Vue.prototype.$off=function(event,fn)&#123; //todo something &#125;&#125; 下面将详细介绍vm.$on 、 vm.$once 、vm.$off 、vm.$emit 实现原理 vm.$on(event,callback)使用说明作用：监听当前实例上自定义事件，事件由emit 触发。回调函数会接收所有事件触发函数的额外参数 参数说明： 12&#123;string | Array&lt;string&gt;&#125; event&#123;Function&#125; callback 示例: 1234vm.$on(&#x27;test&#x27;,function(msg)&#123; console.log(msg) // &#x27;hi&#x27;&#125;)vm.$emit(&#x27;test&#x27;,&#x27;hi&#x27;) 实现原理注册事件时将回调函数收集起来，触发事件时将收集起来的回调依次调用。vm.$on 需要做的事，就是将回调函数收集起来 1234567891011Vue.prototype.$on=function(event,fn)&#123; const vm=this; if(Array.isArray(event))&#123; for(let i=0;i&lt;event.length;i++)&#123; this.$on(event[i],fn) &#125; &#125;else&#123; (vm._events[event] || vm._events[event]=[]).push(fn) &#125; return vm&#125; 上述代码中的 vm._events 在 new Vue 初始化时候 在Vue.js实例上创建_events 属性，用于存储事件。 vm._events=Object.create(null) vm.$emit(event,[…args])使用说明触发实例上的事件，并将参数传递给监听器回调。 参数说明： 12&#123;string &#125; event[...args] 示例: 1234vm.$on(&#x27;test&#x27;,function(msg)&#123; console.log(msg) // &#x27;hi&#x27;&#125;)vm.$emit(&#x27;test&#x27;,&#x27;hi&#x27;) 实现原理vm.$on 将事件监听器回调函数都存储在vm._events 中，vm.$emit 从vm._event 中取出事件监听器回调函数列表，依次执行列表中的回调函数并传入参数 1234567891011121314Vue.prototype.$emit=function(event,...args)&#123; const vm=this; let cbs=vm._events[event] if(cbs)&#123; for(let i=0;i&lt;cbs.length;i++)&#123; try&#123; cbs[i].apply(vm,args) &#125;catch(err)&#123; console.log(err) &#125; &#125; &#125; return vm&#125; vm.$off( [event, callback] )使用说明移除自定义事件的监听器 如果没有提供参数，则移除所有事件监听器 如果只提供了事件，则移除该事件所有的监听器 如果同时提供了事件与回调，则移除这个回调得监听器 参数说明：{string | Array} event{Function} callback 实现原理根据提供的参数情况，来移除监听器 123456789101112131415161718192021222324252627282930313233343536373839Vue.prototype.$off=function(event,fn)&#123; const vm=this; //情况一：没有参数移除所有事件监听器 if(!arguments.length)&#123; vm._events=Object.create(null) return vm &#125; //处理参数为数组的情况 if(Array.isArray(event))&#123; // event 为数组 for(let i=0;i&lt;event.length;i++)&#123; this.$off(event[i],fn) &#125; return vm &#125; const cb=this._events[event]; if(!cbs)&#123; return vm &#125; //情况二: 只提供了事件，移除该事件所有的监听器 if(arguments.length ===1)&#123; this._events[event]=null return vm &#125; //情况三：同时提供了事件和回调函数，只移除与fn相同的监听器 if(fn)&#123; const cbs=vm._events[event]; let cb; let i=cbs.length; while(i--)&#123; //细节注意：从后往前遍历，不会影响到未遍历到的监听器 cb=cbs[i]; if(cb===fn || cb.fn===fn)&#123; //cb.fn===fn 是干啥的？vm.$once中具体讲解 cbs.splice(i,1); break &#125; &#125; return vm &#125;&#125; vm.$once(event,callback)使用说明监听一个自定义事件，但只触发一次，在一次触发之后移除监听器 参数：{string | Array} event{Function} callback 实现原理监听一个自定义事件，但只触发一次，在一次触发之后移除监听器。上述描述可以使用vm.$on 来监听事件， 使用vm.$off移除监听 12345678910Vue.prototype.$once=function(event,fn)&#123; const vm=this; function on(...args)&#123; vm.$off(event,on) //移除自定义事件监听器 fn.apply(vm,args) //触发回调 &#125; on.fn=fn //这里为啥这样呢？思考一下 vm.$on(event,on) return vm&#125; 为什么会有 on.fn=fn 这行代码？思考一个场景，用户在触发事件之前调用vm.$off,那么用户会这么写：vm.$off(&#39;xxx&#39;,fn)而此时_events是这样的：vm._events=&#123;&#39;xxx&#39;:[on]&#125;,on 和 fn 不一致那么就不会溢出监听器。结合vm.$off源码，如果on和fn不相等的时候，还会判断on.fn 和 fn 是否相等，如果相等也会移除监听器。这也就是为什么要写on.fn=fn 这行代码的原因。 12345//vm.$off 源码片段if(cb===fn || cb.fn===fn)&#123; cbs.splice(i,1); break &#125; 设计模式Vue 的事件使用了发布订阅模式，有关发布订阅模式的详细介绍可以看这里 点我","categories":[{"name":"Vue","slug":"Vue","permalink":"https://mandylucky.github.io/categories/Vue/"}],"tags":[{"name":"Vue实例方法","slug":"Vue实例方法","permalink":"https://mandylucky.github.io/tags/Vue%E5%AE%9E%E4%BE%8B%E6%96%B9%E6%B3%95/"},{"name":"Vue深入浅出读书笔记","slug":"Vue深入浅出读书笔记","permalink":"https://mandylucky.github.io/tags/Vue%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"}]}],"categories":[{"name":"Vue","slug":"Vue","permalink":"https://mandylucky.github.io/categories/Vue/"},{"name":"js","slug":"js","permalink":"https://mandylucky.github.io/categories/js/"},{"name":"浏览器","slug":"浏览器","permalink":"https://mandylucky.github.io/categories/%E6%B5%8F%E8%A7%88%E5%99%A8/"},{"name":"编程之外","slug":"编程之外","permalink":"https://mandylucky.github.io/categories/%E7%BC%96%E7%A8%8B%E4%B9%8B%E5%A4%96/"},{"name":"算法","slug":"算法","permalink":"https://mandylucky.github.io/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"最佳实践","slug":"最佳实践","permalink":"https://mandylucky.github.io/tags/%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/"},{"name":"ES6","slug":"ES6","permalink":"https://mandylucky.github.io/tags/ES6/"},{"name":"CORS","slug":"CORS","permalink":"https://mandylucky.github.io/tags/CORS/"},{"name":"浏览器存储","slug":"浏览器存储","permalink":"https://mandylucky.github.io/tags/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%AD%98%E5%82%A8/"},{"name":"浏览器缓存","slug":"浏览器缓存","permalink":"https://mandylucky.github.io/tags/%E6%B5%8F%E8%A7%88%E5%99%A8%E7%BC%93%E5%AD%98/"},{"name":"浏览器架构","slug":"浏览器架构","permalink":"https://mandylucky.github.io/tags/%E6%B5%8F%E8%A7%88%E5%99%A8%E6%9E%B6%E6%9E%84/"},{"name":"浏览器跨域","slug":"浏览器跨域","permalink":"https://mandylucky.github.io/tags/%E6%B5%8F%E8%A7%88%E5%99%A8%E8%B7%A8%E5%9F%9F/"},{"name":"异步","slug":"异步","permalink":"https://mandylucky.github.io/tags/%E5%BC%82%E6%AD%A5/"},{"name":"学习方法","slug":"学习方法","permalink":"https://mandylucky.github.io/tags/%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%B3%95/"},{"name":"STAR","slug":"STAR","permalink":"https://mandylucky.github.io/tags/STAR/"},{"name":"自我提升","slug":"自我提升","permalink":"https://mandylucky.github.io/tags/%E8%87%AA%E6%88%91%E6%8F%90%E5%8D%87/"},{"name":"Vue深入浅出读书笔记","slug":"Vue深入浅出读书笔记","permalink":"https://mandylucky.github.io/tags/Vue%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"},{"name":"响应式原理","slug":"响应式原理","permalink":"https://mandylucky.github.io/tags/%E5%93%8D%E5%BA%94%E5%BC%8F%E5%8E%9F%E7%90%86/"},{"name":"你不知道的js读书笔记","slug":"你不知道的js读书笔记","permalink":"https://mandylucky.github.io/tags/%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84js%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"},{"name":"js基础","slug":"js基础","permalink":"https://mandylucky.github.io/tags/js%E5%9F%BA%E7%A1%80/"},{"name":"算法基础","slug":"算法基础","permalink":"https://mandylucky.github.io/tags/%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80/"},{"name":"数据结构","slug":"数据结构","permalink":"https://mandylucky.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"Vue实例方法","slug":"Vue实例方法","permalink":"https://mandylucky.github.io/tags/Vue%E5%AE%9E%E4%BE%8B%E6%96%B9%E6%B3%95/"}]}