---
title: 浏览器同源政策及其规避方法
tags: []
toc: true
date: 2021-05-17 22:08:22
categories: 浏览器
---
# 概述

### 含义
浏览器有同源政策

**所谓"同源"指的是"三个相同"**
- 域名相同
- 协议相同
- 端口相同

### 目的
同源策略的目的是为了保证用户信息的安全，防止恶意的网站窃取数据

### 限制范围
如果是非同源，有三种行为受到限制
1. Ajax 请求不能发送
2. DOM 无法获取
3. Cookie、LocalStorage、IndexDB 无法读取

# Cookie 规避同源的方法
1. iframe 窗口 + 一级域名相同
Cookie 只有同源的网页才能共享，但是两个一级域名相同的的网页，浏览器允许通过设置```document.domain```共享Cookie，这种方法只适用于 Cookie 和 iframe 窗口。  

2. 设置Cookie的时候，指定所属域名为一级域名 eg: ```Set-Cookie: key=value; domain=.example.com; path=/```,这样的话二级域名和三级域名都可以读取这个cookie 



# iframe
两个网页不同源，就无法拿到对方的DOM。eg:iframe窗口和window.open方法打开的窗口，它们与父窗口无法通信 

### 如果两个窗口一级域名相同，只是二级域名不同

那么设置上一节介绍的document.domain属性，就可以规避同源政策，拿到DOM

### 对于完全不同源的网站   
#####  片段识别符 
片段标识符（fragment identifier）指的是，URL的#号后面的部分。如果只是改变片段标识符，页面不会重新刷新。父窗口可以把信息，写入子窗口的片段标识符。
```js
var src = originURL + '#' + data;
document.getElementById('myIFrame').src = src;
```
子窗口通过监听 ```hashchange``` 事件得到通知
```js
window.onhashchange = checkMessage;

function checkMessage() {
  var message = window.location.hash;
  // ...
}
``` 
同样的，子窗口也可以改变父窗口的片段标识符。
```js
parent.location.href= target + "#" + hash;
```
#####  window.name 
浏览器窗口有window.name 属性，该属性无论是否同源，只要在同一个窗口里，前一个网页设置了这个属性，后一个网页可以读取它

```js
// 主窗口读取子窗口的window.name
var data = document.getElementById('myFrame').contentWindow.name;
```
这种方法的优点是，window.name容量很大，可以放置非常长的字符串；缺点是必须监听子窗口window.name属性的变化，影响网页性能

#####  window.postMessage  
HTML5为了解决这个问题，引入了一个全新的API：跨文档通信API
window.postMessage方法，允许跨窗口通信，不论两个窗口是否同源。

```js
// 语法
otherWindow.postMessage(message, targetOrigin, [transfer]);

// otherWindow:其他窗口的一个引用，比如iframe的contentWindow属性、执行window.open返回的窗口对象、或者是命名过或数值索引的window.frames。

// message:将要发送到其他 window的数

// targetOrigin :通过窗口的origin属性来指定哪些窗口能接收到消息事件，其值可以是字符串"*"（表示无限制）或者一个URI。
```
```js
// 父窗口http://aaa.com向子窗口http://bbb.com发消息，调用postMessage方法就可以了
var popup = window.open('http://bbb.com', 'title');
popup.postMessage('Hello World!', 'http://bbb.com');
```
父窗口和子窗口都可以通过message事件，监听对方的消息。

```js
window.addEventListener('message', function(e) {
  console.log(e.data);
},false);
```

message事件的事件对象event，提供以下三个属性
- event.source：发送消息的窗口
- event.origin: 消息发向的网址
- event.data: 消息内容

#####  LocalStorage
通过window.postMessage，子窗口将父窗口发来的消息，写入自己的LocalStorage

```js

window.onmessage = function(e) {
  if (e.origin !== 'http://bbb.com') {
    return;
  }
  var payload = JSON.parse(e.data);
  localStorage.setItem(payload.key, JSON.stringify(payload.data));
};
```
# AJAX
同源政策规定，AJAX请求只能发给同源的网址，否则就报错。
有三种方法规避限制
- JSONP
- WebSocket
- CORS

### JSONP
优点：最大特点就是简单适用，老式浏览器全部支持，服务器改造非常小。

原理： 它的基本思想是，网页通过添加一个```<script>```元素，向服务器请求JSON数据，这种做法不受同源政策限制；服务器收到请求后，将数据放在一个指定名字的回调函数里传回来。 

```js
function addScriptTag(src) {
  var script = document.createElement('script');
  script.setAttribute("type","text/javascript");
  script.src = src;
  document.body.appendChild(script);
}

window.onload = function () {
  addScriptTag('http://example.com/ip?callback=foo');
}

function foo(data) {
  console.log('Your public IP address is: ' + data.ip);
};
```
### WebSocket 
WebSocket是一种通信协议，使用ws://（非加密）和wss://（加密）作为协议前缀。该协议不实行同源政策，只要服务器支持，就可以通过它进行跨源通信。

览器发出的WebSocket请求的头信息有一个字段是Origin，表示该请求的请求源（origin），即发自哪个域名。服务器可以根据这个字段，判断是否许可本次通信。

### CORS【跨域资源共享】  
CORS需要浏览器和服务器同时支持。目前，所有浏览器都支持该功能，IE浏览器不能低于IE10。

整个CORS通信过程，都是浏览器自动完成，浏览器一旦发现AJAX请求跨源，就会自动添加一些附加的头信息。因此，实现CORS通信的关键是服务器。只要服务器实现了CORS接口，就可以跨源通信。

另外，CORS请求默认不发送Cookie和HTTP认证信息。如果要把Cookie发到服务器，一方面要服务器同意，指定Access-Control-Allow-Credentials字段。另一方面，开发者必须在AJAX请求中打开withCredentials属性（设置为true）。

# 总结
1. cookie 规避同源的方法
- 一级域名相同+iframe:document.domain
- 设置cookie 的时候,domain 设置为.example.com 的形式

2. iframe

(1)域名完全不同       
- 设置hash+ window.onhashchange
- window.name
- window.postMessage+ window.addEventListener('message', function(e){})

(2)一级域名相同     
- document.domain 

3. AJAX
- jsonp 
- websocket
- cors

> [阮一峰浏览器同源政策及其规避方法](https://www.ruanyifeng.com/blog/2016/04/same-origin-policy.html)