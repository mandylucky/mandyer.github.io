---
title: 浏览器缓存
tags: []
toc: true
date: 2021-05-17 22:08:22
categories: 浏览器
---
# 概述
浏览器每次发起请求，先在本地缓存中查找结果及缓存标识，根据缓存标识判断是否使用本地缓存，如果缓存有效则使用缓存；否则携带缓存标识向服务器发起请求。  

根据是否需要向服务器发起HTTP请求将缓存分为：强缓存、协商缓存 
【强缓存优于协商缓存】
- 强缓存:服务器通知浏览器一个缓存时间，在缓存时间内再次发送请求，直接用缓存，不在时间内则进入协商缓存  

- 协商缓存：将缓存信息中的Etag和Last Modified 通过请求发送给服务器，如果服务器校验返回304则直接使用缓存，200 则使用服务器返回的新资源


Http缓存都是从第二次请求开始的
- 第一次请求资源时，服务器返回资源，并在响应头中回传资源的缓存策略 

- 第二次请求时，浏览器判断这些请求头，命中缓存就直接返回200 使用缓存资源，否则发送请求到服务器，服务端判断，若缓存没有修改则返回304，否则返回新资源。  


# 强缓存  
控制强缓存字段：Cache-Control(http 1.1) 、Expires (http1.0)
**Cache-Control > Expires**

### Expires
该字段是服务器的响应头字段，告诉浏览器在过期时间(绝对时间)之前可以直接从浏览器缓存中取数据  

缺点：
- 服务器时间和客户端时间可能不一致，这种情况下浏览器判断将出错 
- 到期之前修改，客户端是不可知的  

### Cache-Control
该字段表示资源缓存的最大有效时间（相对时间），在该时间内客户端不需要向服务端发送请求

**部分指令:**

- public:所用内容都可以被缓存 （包括：客户端、代理服务器(CDN)）
- private: 所有内容只有客户端才可以缓存
- no-cache: 不使用强缓存，需要与服务器验证缓存是否过期 
- max-age:最大有效期 
- no-store: 真正的不要缓存，所有内容不走缓存，包括强缓存和协商缓存 

优点：解决了Expires客户端与服务端时间不一致的问题
缺点：到期之前修改，客户端是不可知的

# 协商缓存
当浏览器强制缓存失败，或者请求头中设置不走强缓存，并且在请求头设置了if-Modified-Since 或者 if-None-Match 的时候，会将这两个属性值到服务端验证，是否命中协商缓存，如果命中返回304，加载浏览器缓存，并在响应头设置 Etag / Last-Modified 属性 

协商缓存有两组字段：Last-Modified/f-Modified-Since 、Etag/if-None-Match 

**Etag > Last-Modified** 

### Last-Modified/if-Modified-Since
服务器 通过Last-Modified告诉客户端最后一次修改时间，这个值和内容一起保存在缓存中，下一次请求相同资源进入协商缓存时，请求头中奖上一次的Last-Modified值写入到请求头if-Modified-Since字段 


优势：相对强制缓存而言，协商缓存每次都会进行比对，有资源更新第一时间获取到。

缺点：
- 时间修改，但是内容可能没有修改
- Last-Modified以秒为单位，如果一秒多次修改数据，客户端只会获取到一秒内第一次修改的内容

### Etag/if-None-Match 
Etag 是文件的特殊标识（hash生成），流程和Last-Modified一致 

优点：
- 可以识别一秒内多次修改
- 相对强制缓存而言，协商缓存每次都会进行比对，有资源更新第一时间获取到。

缺点：
- 计算Etag的值，需要性能消耗
- 分布式服务器存储要保证Etag 的算法一致

