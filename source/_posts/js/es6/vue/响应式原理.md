---
title: 响应式原理
tags: ['Vue深入浅出读书笔记','响应式原理']
toc: true
date: 2021-05-15 08:03:11
categories: Vue
---
#### 深入响应式原理   
[一、Vue是如何实现响应式对象和数组的?](#Vue是如何实现响应式对象和数组的?)  
[1.初始化阶段,对象变成响应式对象的过程](#初始化阶段,对象变成响应式对象的过程)  
[2.对象添加属性&数组](#对象添加属性&数组)   
[2.1对象添加属性](#对象添加属性)    
[2.2数组](#数组)    

[二、依赖收集](#依赖收集)  
[1.Dep](#Dep)  
[2.Watcher](#Watcher)    
[3.分析过程](#分析过程)  

[三、派发更新](#派发更新)  
[1.分析过程](#派发更新过程分析)  

[四、nextTick](#nextTick)  



## <a id="Vue是如何实现响应式对象和数组的?">Vue是如何实现响应式对象和数组的?</a>  
Vue2.x 实现响应式的核心是利用了 ES5 的 Object.defineProperty(不能兼容 IE8 及以下浏览器)  

语法:
```
Object.defineProperty(obj, prop, descriptor)

//obj:要定义属性的对象
//prop：要定义/修改的属性名称
//descriptor:要定义或修改的属性描述符
```
> Object.defineProperty用于在一个对象上定义新属性/修改现有属性，并返回此对象  

我们最关心的是descriptor的get和set    
- get 给属性提供getter 方法，当我们访问了该属性的时候会触发getter 方法
- set 是一个给属性提供的setter 方法，当我们对该属性做修改的时候会触发setter方法

==一旦对象拥有了getter和setter，我们就可以简单的把这个对象称为响应式对象==  

### <a id="初始化阶段,对象变成响应式对象的过程">初始化阶段,对象变成响应式对象的过程</a>
props和data 初始化的目的，都是把它们变成响应式对象

**props初始化中，props 变成响应式对象的过程**

```
function initProps(propsOptions){
     const props = vm._props = {}
    for (const key in propsOptions) {
        //....
         const value = validateProp(key, propsOptions, propsData, vm)
         defineReactive(props, key, value)
    }
}
```

**data 初始化中，data 变成响应式对象的过程**

```
function initData () {
    //..... 
    observe(data) //把 data 也变成响应式
}

```

```
export function observe (value) {
//.....
let  ob = new Observer(value)
return ob
}
```

```
export class Observer {
 constructor (value) {
    this.value = value
    //...
    if (Array.isArray(value)) {
       const augment = hasProto
        ? protoAugment
        : copyAugment
      augment(value, arrayMethods, arrayKeys)
      this.observeArray(value)
    } else {
      this.walk(value)
    }
  }
  //只有对象才可调用
  walk(obj){
    for (let i = 0; i < keys.length; i++) {
      defineReactive(obj, keys[i])
    }
  }
  
  observeArray (items) {
    for (let i = 0, l = items.length; i < l; i++) {
      observe(items[i])
    }
  }

}
```
Observer 构造函数对value判断，纯对象调用walk(遍历对象的key调用defineReactive方法)，若果是数组则调用observeArray方法(遍历数组，再次调用observe)


**defineReactive**   
defineReactive 的功能就是定义一个响应式对象，给对象动态添加getter 和 setter 


```
export function defineReactive (obj,key,val){
    const property = Object.getOwnPropertyDescriptor(obj, key)
    if (property && property.configurable === false) {
        return
    }
    
    const getter = property && property.get
    const setter = property && property.set
    if ((!getter || setter) && arguments.length === 2) {
        val = obj[key]
    }
    //....
    Object.defineProperty(obj, key, {
    enumerable: true,
    configurable: true,
    get: function reactiveGetter () {
          const value = getter ? getter.call(obj) : val
          return value
    },      
    set: function reactiveSetter (newVal) {
        //....
        if (setter) {
            setter.call(obj, newVal)
        } else {
            val = newVal
        }
        //.....
    }    
 })
}
```
defineReactive 函数利用Object.defineProperty给数据添加了getter 和 setter 使对象变成了 响应式对象，我们可以在访问数据和写入数据时自动执行一些逻辑来完成响应式

**总结：
初始化阶段将props 和 data 的变成响应式数据的过程：
如果是对象则遍历变量对象的每个属性（configurable 键值为 true），为属性提供getter/setter 方法，如果是数组，修改原型，将其指向arrayMethods(下面会具体说明),遍历数组的每一项进行上述处理** 
### <a id="对象添加属性&数组">对象添加属性&数组</a>

#### <a id="对象添加属性">对象添加属性</a>
使用Object.defineProperty 实现响应式的对象，当我们去给这个对象添加一个新属性的时候，是不能够触发它的setter 的   


这种场景在我们平时开发中经常遇到，那么vue为了解决这个问题，定义了一个全局API Vue.set 方法 


global-api/index.js
```
Vue.set=set;
```
> Vue.set向响应式对象中添加一个 property，并确保这个新 property 同样是响应式的，且触发视图更新。它必须用于向响应式对象上添加新 property，因为 Vue 无法探测普通的新增 property

observer/index.js

```
//target:数组/普通对象
//key:代表数组下标或者对象的键值
export function set(target,val){ 
    if(Array.isArray(target)&& isValidArrayIndex(key)){//target 是数组且key是合法下标，则通过splice去添加进数组然后返回
        target.splice(key, 1, val) //这里的splice不是原生的方法了，而是被Vue 处理过的
        return val
    }
    if (key in target && !(key in Object.prototype)) {//对于已经存在与target中的key，直接赋值返回，因为这样的变化是可以被观测到的
        target[key] = val
        return val
  }
  const ob = (target: any).__ob__ //__ob__是在Observer 的构造函数执行时初始化的，表示Observer 的一个实例。
  //......
  if(!ob){//如果__ob__不存在到的话说明target 不是一个响应式的对象,则直接赋值并返回。
       target[key] = val
       return val
  }
  defineReactive(ob.value, key, val)//最后通过defineReactive把新添加的属性变成响应式对象
  ob.dep.notify()//手动触发依赖通知
  return val
}

```
#### <a id="数组">数组</a>

Vue 也不能检测到以下的数组变动 

- 利用索引直接设置一个项时 `vm.items[indexOfItem] = newValue`
- 修改数组的长度`vm.items.length = newLength`

第一个问题的解决方法`Vue.set(vm.items, indexOfItem, newValue)`    
第二个问题的解决方法`vm.items.splice(indexOfItem, 1, newValue)`

其实第一个问题的解决方式本质上与第二个问题的解决方式是一样的，在Vue.set内部会判断如果是数组的话，也是使用splice方法处理 ` target.splice(key, 1, val)`

上面用到的splice 方法是被vue 改写过的方法了，下面会对这部分进行详细的说明


observe 方法观察对象的时候会实例化Observer，在Observer 的构造函数中专门对数组做了处理

```
export class Observer {
  constructor (value: any) {
    this.value = value
    this.dep = new Dep()
    this.vmCount = 0
    def(value, '__ob__', this)
    if (Array.isArray(value)) {
      const augment = hasProto
        ? protoAugment
        : copyAugment
      augment(value, arrayMethods, arrayKeys)
      this.observeArray(value)
    } else {
      // ...
    }
  }
}
```
hasProto 判断对象中是否存在__proto__,存在augment 指向protoAugment否则指向copyAugment   



```
function protoAugment (target, src, keys) {
    target.__proto__ = src
}
```
protoAugment 方法是直接把 target.__proto__ 原型直接修改为 src

```
function copyAugment (target, src, keys) {
  for (let i = 0, l = keys.length; i < l; i++) {
    const key = keys[i]
    def(target, key, src[key])
  }
}
```
copyAugment 方法是遍历 keys，通过 def，也就是 Object.defineProperty 去定义它自身的属性值

**大部分现代浏览器会走到protoAugment**   

```
 augment(value, arrayMethods, arrayKeys)
```
那么再看这行代码，实际上就是把value 的原型指向了arrayMethods


```
const arrayProto = Array.prototype
export const arrayMethods = Object.create(arrayProto)

const methodsToPatch = [
  'push',
  'pop',
  'shift',
  'unshift',
  'splice',
  'sort',
  'reverse'
] //methodsToPatch中定义了所有能改变数组本身的方法
methodsToPatch.forEach(function (method) {
  const original = arrayProto[method]//缓存原生方法
  def(arrayMethods, method, function mutator (...args) { //def 函数是一个非常简单的Object.defineProperty 的封装
    const result = original.apply(this, args)
    const ob = this.__ob__
    let inserted
    switch (method) {
      case 'push':
      case 'unshift':
        inserted = args
        break
      case 'splice':
        inserted = args.slice(2)
        break
    }
    if (inserted) ob.observeArray(inserted) //把新添加的值变成一个响应式对象
    // notify change
    ob.dep.notify()//手动触发依赖通知
    return result
  })
})
```

arrayMethods首先继承了Array,然后对数组中所有能改变数组自身的方法，eg:push、pop等 方法进行重写。重写后的方法会先执行它们本身原有的逻辑，对能增加长度的3个方法push、unshift、splice 方法做了判断，获取插入的值，然后把新增的值变成一个响应式对象。最后调用ob.dep.notify 手动触发依赖通知

### <a id="依赖收集">依赖收集</a>
Vue 把普通对象变成响应式对象，响应式对象getter 相关逻辑就是做依赖收集的


```
export function defineReactive (obj,key,val){
    const dep = new Dep()//关注1：实例化一个 Dep 的实例
      //...
    Object.defineProperty(obj, key, {
    enumerable: true,
    configurable: true,
    get: function reactiveGetter () {
      const value = getter ? getter.call(obj) : val
      if (Dep.target) {
        dep.depend() //dep.depend 做依赖收集
        if (childOb) {
          childOb.dep.depend()
          if (Array.isArray(value)) {
            dependArray(value)
          }
        }
      }
      return value
    },
    // ...
  })
}
```
**两个重点关注     
1.实例化了一个Dep的实例     
2.getter 中 通过dep.depend 做依赖收集**  

下面先了解一下Dep
#### <a id="Dep">Dep</a>
Dep 是整个 getter 依赖收集的核心
```
let uid = 0
export default class Dep {
    //....
    static target;// 全局唯一Watcher(同一时间内，只能有一个全局Watcher 被计算)
    id;
    subs;
    constructor () {
        this.id = uid++
        this.subs = [] //watcher 的数组
    }
    addSub(sub){
        this.subs.push(sub)
    }
    removeSub(sub){
        remove(this.subs, sub)
    }
    depend () {
        if (Dep.target) {
          Dep.target.addDep(this)
        }
    }
    notify () {
        const subs = this.subs.slice()
        for (let i = 0, l = subs.length; i < l; i++) {
          subs[i].update()
        }
    }
}
Dep.target = null
const targetStack = []

export function pushTarget (_target: ?Watcher) {
  if (Dep.target) targetStack.push(Dep.target)
  Dep.target = _target
}

export function popTarget () {
  Dep.target = targetStack.pop()
}
```
Dep 是一个 Class，它定义了一些属性和方法，静态属性target,是一个全局唯一Watcher(同一时间只有一个全局Watcher,因为同一时间只能有一个全局Watcher 被计算)，自身属性subs也是Watcher 的数组  

Dep 实际上是对Watcher 的一种管理   


下面先了解一下Watcher
#### <a id="Watcher">Watcher</a>
```
let uid = 0
export default class Watcher {
     vm;
     expression;
     cb;
     id;
     deep;
     user;
     computed;
     sync;
     dirty;
     active;
     dep;
     deps;
     newDeps;
     depIds;
     newDepIds;
     before;
     getter;
     value;
    constructor(vm,expOrFn,cb,options,isRenderWatcher){
        this.vm = vm
        if (isRenderWatcher) {
            vm._watcher = this
        }
        vm._watchers.push(this)
        //options
        if (options) {
            this.deep = !!options.deep
            this.user = !!options.user
            this.computed = !!options.computed
            this.sync = !!options.sync
            this.before = options.before
        } else {
          this.deep = this.user = this.computed = this.sync = false
        }
        this.cb = cb
        this.id = ++uid // uid for batching
        this.active = true
        this.dirty = this.computed // for computed watchers
        this.deps = []
        this.newDeps = []
        this.depIds = new Set()
        this.newDepIds = new Set()
        this.expression = process.env.NODE_ENV !== 'production'
          ? expOrFn.toString()
          : ''
        // parse expression for getter
        if (typeof expOrFn === 'function') {
          this.getter = expOrFn
        } else {
          this.getter = parsePath(expOrFn)
          if (!this.getter) {
            this.getter = function () {}
            //正式环境警告！...
          }
        }
        if (this.computed) {
          this.value = undefined
          this.dep = new Dep()
        } else {
          this.value = this.get()
        }
    }
    get(){
        pushTarget(this)
        let value
        const vm = this.vm
        try {
            value = this.getter.call(vm, vm)
        }catch(e){
            //....
        }finally{
            if (this.deep) {
                traverse(value)
            }
            popTarget()
            this.cleanupDeps()
        }
        return value
    }
    addDep(){
        const id = dep.id
        if (!this.newDepIds.has(id)) {
            this.newDepIds.add(id)
            this.newDeps.push(dep)
            if (!this.depIds.has(id)) {
                 dep.addSub(this)
            }
        }
    }
    cleanupDeps(){
        let i = this.deps.length
        while (i--) {
          const dep = this.deps[i]
          if (!this.newDepIds.has(dep.id)) {
            dep.removeSub(this)
          }
        }
        let tmp = this.depIds
        this.depIds = this.newDepIds
        this.newDepIds = tmp
        this.newDepIds.clear()
        tmp = this.deps
        this.deps = this.newDeps
        this.newDeps = tmp
        this.newDeps.length = 0        
    }
    //....
}
```
Watcher 是一个Class,在构造函数中定义了一些和Dep相关的属性

this.deps、this.newDeps:   
表示 Watcher 实例持有的 Dep 实例的数组

this.depIds、this.newDepIds:   
分别代表 this.deps 和 this.newDeps 的 id Set  

Watcher 还定义了一些和依赖收集相关的原型方法。

#### <a id="分析过程">分析过程</a>
访问数据对象会触发getter，下面先说下对象什么时候被访问 

Vue 的 mount 过程是通过 mountComponent 函数，其中有一段比较重要的逻辑，如下：
```
updateComponent = () => {
  vm._update(vm._render(), hydrating)
}
new Watcher(vm, updateComponent, noop, {
  before () {
    if (vm._isMounted) {
      callHook(vm, 'beforeUpdate')
    }
  }
}, true /* isRenderWatcher */)
```
上面代码实例化了一个watcher,进入watcher构造函数逻辑，执行this.get()方法，进入get函数首先会执行pushTarget(this)【把 Dep.target 赋值为当前的渲染 watcher 并压栈】，接着执行value = this.getter.call(vm, vm)，this.getter实际上执行的是vm._update(vm._render(), hydrating)，执行vm._render()方法会生成渲染VNode,在这个过程中会对vm上的数据访问，这个时候也就触发了数据对象的getter

每个对象值的getter都一个dep,在触发getter的时候会调用dep.depend()，也就会执行Dep.target.addDep(this)

Dep.target 已经被赋值为渲染 watcher,那么就执行到addDep方法

```
addDep (dep: Dep) {
  const id = dep.id
  if (!this.newDepIds.has(id)) {
    this.newDepIds.add(id)
    this.newDeps.push(dep)
    if (!this.depIds.has(id)) {
      dep.addSub(this)
    }
  }
}
```
做逻辑判断确保同一个数据不会添加多次，然后执行dep.addSub(this),那么就会执行this.subs.push(sub),也就是说把当前watcher订阅到这个数据持有的dep的subs中，为了后续数据变化能够通知到subs

vm._render()过程中，会触发所有数据的getter,这样实际上就完成了一个依赖收集的过程

完成依赖收集后，还有几个逻辑要执行   


```
if (this.deep) {
  traverse(value)
}
```
这个是要递归去访问 value，触发它所有子项的 getter


```
popTarget()
//执行
Dep.target = targetStack.pop()
```
实际上就是把 Dep.target 恢复成上一个状态，因为当前 vm 的数据依赖收集已经完成，那么对应的渲染Dep.target 也需要改变

最后执行:
```
this.cleanupDeps()
```
Vue 是数据驱动的，所以每次数据变化都会重新 render,那么 vm._render() 方法又会再次执行，并再次触发数据的 getters,所以 Watcher 在构造函数中会初始化 2 个 Dep 实例数组，newDeps 表示新添加的 Dep 实例数组，而 deps 表示上一次添加的 Dep 实例数组。

在执行 cleanupDeps 函数的时候，会首先遍历 deps，移除对 dep.subs 数组中 Wathcer 的订阅，然后把 newDepIds 和 depIds 交换，newDeps 和 deps 交换，并把 newDepIds 和 newDeps 清空。



 Vue 设计了在每次添加完新的订阅，会移除掉旧的订阅。这样就保证了。v-if 去渲染不同子模板 a 和 b，如果渲染 b 模板的时候去修改 a 模板的数据，a 数据订阅回调已经被移除了。所以不会有任何浪费。


**总结：
依赖收集的目的是为了当这些响应数据发生变化，触发它们setter的时候，知道通知哪些订阅者**

### <a id="派发更新">派发更新</a>

响应式数据依赖收集的目的就是为了修改数据时可以对相关依赖派发更新   

```
export function defineReactive (obj,key,val,customSetter,shallow) {
  const dep = new Dep()
  //...
  Object.defineProperty(obj, key, {
    enumerable: true,
    configurable: true,
    set: function reactiveSetter (newVal) {
        const value = getter ? getter.call(obj) : val
        if (newVal === value || (newVal !== newVal && value !== value)) {
            return
        }
       //...    
        if (setter) {
            setter.call(obj, newVal)
        } else {
            val = newVal
        }
        childOb = !shallow && observe(newVal)
        dep.notify()   
    }
    //...
    })
 }
```
setter处理逻辑中有两个关键点，childOb = !shallow && observe(newVal)如果 shallow 为 false 的情况，会对新设置的值变成一个响应式对象、dep.notify()通知所有订阅者   

#### <a id="派发更新过程分析">过程分析</a>
当响应式数据做了修改，就会触发setter的逻辑，最后调用dep.notify()


```
class Dep {
  // ...
  notify () {
  // stabilize the subscriber list first
    const subs = this.subs.slice()
    for (let i = 0, l = subs.length; i < l; i++) {
      subs[i].update()
    }
  }
}
```
遍历subs,也就是Watcher的实例数组，然后调用每个watcher的update 方法  

```
class Watcher {
  // ...
  update () {
       if (this.computed) {
           //...
       }else if (this.sync) {
           //...
       }else {
            queueWatcher(this)
       }
  }
}
```
Watcher的不同状态，会执行不同的逻辑，一般组件的数据更新场景会走到queueWatcher(this)

```
export function queueWatcher (watcher) {
     const id = watcher.id
     if (has[id] == null) {
            has[id] = true
            if (!flushing) {
              queue.push(watcher)
            } else {
                let i = queue.length - 
                while (i > index && queue[i].id > watcher.id) {
                     i--
                }
                queue.splice(i + 1, 0, watcher)
            }
             if (!waiting) {
                waiting = true
                nextTick(flushSchedulerQueue)
             }
        }
}
```
首先用 has 对象保证同一个 Watcher 只添加一次；   
接着对flushing 判断    
最后通过waiting保证对 nextTick(flushSchedulerQueue)的调用逻辑只有一次   
nextTick(flushSchedulerQueue),可以先简单理解为异步的去执行flushSchedulerQueue


下面先看下 flushSchedulerQueue的实现 

```
let flushing = false
let index = 0
function flushSchedulerQueue () {
    flushing = true
    let watcher, id
    queue.sort((a, b) => a.id - b.id)
    for (index = 0; index < queue.length; index++) {//queue.length 的原因是用户可能会添加新watcher
        watcher = queue[index]
        if (watcher.before) {
          watcher.before()
        }
        id = watcher.id
        has[id] = null
        watcher.run()
         if (process.env.NODE_ENV !== 'production' && has[id] != null) {
              circular[id] = (circular[id] || 0) + 1
              if (circular[id] > MAX_UPDATE_COUNT) {
                  warn(xxxx)
                  break
              }
         }
    }
    const activatedQueue = activatedChildren.slice()
    const updatedQueue = queue.slice()
    resetSchedulerState() //状态恢复 
    callActivatedHooks(activatedQueue)
    callUpdatedHooks
    if (devtools && config.devtools) {
        devtools.emit('flush')
    }
}
  
```
对上面代码逻辑进行梳理 
- queue.sort((a, b) => a.id - b.id)       
对队列做了从小到大的排序
这么做的目的为了确保以下几点：    
1.组件的更新由父到子（父组件先于子创建，所以watcher创建也是先父后子，执行顺序也应该保持先父后子）         
2.用户自定义watcher要优先于渲染watcher执行执行；因为用户自定义watcher在渲染watcher之前创建         
3.如果一个组件在父组件watcher执行期间被销毁，那么它对应的watcher执行都可以被跳过所以父组件的watcher 也应该先执行   
- 队列遍历   
排序后进行遍历，获取对应的watcher,执行watcher.run()【因为执行的时候可能会添加新的watcher 所以遍历使用queue.length】

watcher.run()部分逻辑分析
```
class Watcher {
    run(){
        if (this.active) {
            this.getAndInvoke(this.cb)
        }
    }
    getAndInvoke(cb){
        const value = this.get()
        if ( value !== this.value || isObject(value) ||  this.deep){
            const oldValue = this.value
            this.value = value
            this.dirty = false
            if (this.user) {
                try {
                  cb.call(this.vm, value, oldValue) //传入oldValue 这是为什么自定义watcher 中能够得到新旧值的原因啦
                } catch (e) {
                  handleError(e, this.vm, `callback for watcher "${this.expression}"`)
                }
            }else{
                cb.call(this.vm, value, oldValue)
            }
        }
    }
}
```
watcher.run() 实际上就是执行 getAndInvoke方法，并传入watcher的回调函数   
先通过 this.get() 得到它当前的值，然后做判断，如果满足新旧值不等、新值是对象类型、deep 模式任何一个条件，则执行 watcher 的回调

对于渲染watcher而言，执行this.get()方法求值的时候，会执行getter方法，触发组件的重新渲染

- 状态恢复   
执行 resetSchedulerState函数,把这些控制流程状态的一些变量恢复到初始。

总结：数据发生变化时，触发setter逻辑，把在依赖过程中订阅的所有观察者（watcher），触发它们的update 过程。这个过程利用队列做了进一步优化，在nextTick后执行所有watcher的run ,最后执行它们的回调函数  

### <a id="nextTick">nextTick</a>  
nextTick 是Vue的一个核心实现  

先了解JS运行机制
1. 所有同步任务都在主线程上执行，形成一个执行栈
2. 主线程之外还存在一个任务队列，只有异步任务有了运行结果，就在任务队列中放置一个事件   
3. 执行栈中所有同步任务执行完毕，就会读取任务对列，进入执行栈，开始执行
4. 主线程不断重复第三步

主线程的执行过程就是一个tick，而所有的异步结果都是通过 “任务队列” 来调度。消息队列中存放的是一个个的任务（task）。 规范中规定 task 分为两大类，分别是 macro task 和 micro task


macro task 和 micro task  伪代码表示
```
for (macroTask of macroTaskQueue) {
    // 1. Handle current MACRO-TASK
    handleMacroTask();
      
    // 2. Handle all MICRO-TASK
    for (microTask of microTaskQueue) {
        handleMicroTask(microTask);
    }
}
```

Vue的实现  

```
const callbacks = []
let pending = false
function flushCallbacks () {
  pending = false
  const copies = callbacks.slice(0)
  callbacks.length = 0
  for (let i = 0; i < copies.length; i++) {
    copies[i]()
  }
}

let microTimerFunc
let macroTimerFunc
let useMacroTask = false

if (typeof setImmediate !== 'undefined' && isNative(setImmediate)) {
  macroTimerFunc = () => {
    setImmediate(flushCallbacks)
  }
} else if (typeof MessageChannel !== 'undefined' && (
  isNative(MessageChannel) ||
  // PhantomJS
  MessageChannel.toString() === '[object MessageChannelConstructor]'
)) {
  const channel = new MessageChannel()
  const port = channel.port2
  channel.port1.onmessage = flushCallbacks
  macroTimerFunc = () => {
    port.postMessage(1)
  }
} else {
  /* istanbul ignore next */
  macroTimerFunc = () => {
    setTimeout(flushCallbacks, 0)
  }
}

if (typeof Promise !== 'undefined' && isNative(Promise)) {
  const p = Promise.resolve()
  microTimerFunc = () => {
    p.then(flushCallbacks)
    // in problematic UIWebViews, Promise.then doesn't completely break, but
    // it can get stuck in a weird state where callbacks are pushed into the
    // microtask queue but the queue isn't being flushed, until the browser
    // needs to do some other work, e.g. handle a timer. Therefore we can
    // "force" the microtask queue to be flushed by adding an empty timer.
    if (isIOS) setTimeout(noop)
  }
} else {
  // fallback to macro
  microTimerFunc = macroTimerFunc
}



export function nextTick(cb,ctx){
  let _resolve
  callbacks.push(() => {
    if (cb) {
      try {
        cb.call(ctx)
      } catch (e) {
        handleError(e, ctx, 'nextTick')
      }
    } else if (_resolve) {
      _resolve(ctx)
    }
  })
  
    if (!pending) {
        pending = true
        if (useMacroTask) {
          macroTimerFunc()
        } else {
          microTimerFunc()
        }
    }
  
    if (!cb && typeof Promise !== 'undefined') {
        return new Promise(resolve => {
          _resolve = resolve
        })
    }
  
}
```
macro tast函数：优先检测是否支持原生setImmediate,不支持的话检查是否支持原生MessageChannel,如果也不支持就会降级为setTimeout

micro task函数：检查浏览器是否原生支持promise,不支持的话直接指向macro task


nexTick：把传入的回调函数cb压入callbacks数组，最后一次性地根据useMacroTask 条件执行macroTimerFunc || microTimerFunc，而它们都会在下一个 tick 执行 flushCallbacks（flushCallbacks是对 callbacks 遍历，然后执行相应的回调函数）

使用callbacks 而不是直接在nextTick执行回调函数的原因是保证在同一个tick 多次执行nextTick，不会启多个异步任务，而是把这些异步任务都压成一个同步任务，在下一个tick 执行
