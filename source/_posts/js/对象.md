---
title: 对象
tags: ['你不知道的js读书笔记','js基础']
toc: true
date: 2021-05-12 23:35:38
categories: js
---
# 语法
**两种形式定义:声明(文字)形式、构造形式**
```js
// 文字形式
var myObj={
    key:value
    //...
}
// 构造形式
var myObj=new Object();
myObj.key=value
```

# 类型
数组是对象的一种子类型，函数也是对象的一种子类型，内置对象（String、Number、Boolean、Object、Function、Array、Date、RegExp、Error） 也是对象的一种子类型

```js
var str="i am a string";
typeof str;//string
str.length //13

var strObject=new String("i am a string");
typeof strObject //"object"
```

**之所以能在字面量上面直接访问属性或者方法，因为引擎自动把字面量转换成string对象，所以可以访问属性和方法**


- null和undefined 没有对应的构造形式，只有文字
- Date 只有构造形式，没有文字
- Object、Array、Function、RegExp 无论使用文字形式还是构造形式，他们都是对象
- Error 对象一般都是在抛出异常时自动创建

# 内容
- 对象的属性名永远都是字符串
- 访问属性：两种方式 . 和  [".."],. 要求属性名满足标识符命名规范，[".."] 语法可以接收任意字符串 

### 可计算属性名
使用[]包裹一个表达式来当作属性名，最常用的场景是ES6 的Symbol

```js
const prefix="foo";
const key1 = Symbol('description');
var myObj={
    [prefix+'bar']:"hello"
    [key1]:"world"
}
```

### 属性与方法
如果访问对象属性是一个函数，被称为 "方法访问"，其他情况称为 "属性访问"

### 复制对象
浅拷贝：```Object.assign()```
深拷贝：```JSON.parse(JSON.stringify(someObj))```

### 属性描述符

**ES5之后所有属性都具备了属性描述符**
```js
var myObj={
    a:2
}
Object.getOwnPropertyDescriptor(myObj,"a")
// {
//     value:2,
//     writable:true,
//     enumerable:true,
//     configurable:true
// }
```

创建普通属性时属性描述符会有默认值,我们也可以使用```Object.defineProperty(...)```来添加一个新属性或者修改一个已有属性（configurable为true时）并对其特性进行配置

```js
var myObject={}
Object.defineProperty(myObject,"a",{
    value:2,
    writable:true,
    configurable:true,
    enumerable:true
})
myObject.a //2
```
1. **Writable:** 决定是否可以修改属性值   
2. **Configurable:** 设置属性是否可配置，只要属性是可配置的就可以使用defineProperty(...)方法来修改属性描述符。configurable 只能由true 改为false ,不能由false 改为true。且不能删除属性 delete 语句会失败
3. **Enumerable:** 用于控制属性是否会出现在对象的属性枚举中。
4. **getter** 后面会详细介绍
5. **setter** 后面会详细介绍

**不变性**
- 对象常量 
结合writeable:false 和 configurable 就可以创建一个真正的常量属性（不可修改，从定义或者删除） 
```js
var myObj={}
Object.defineProperty(myObj,"FAVORITE_NUMBER",{
    value:42;
    writable:false,
    configurable:false
})
```
- 禁止扩展(prevent Extensions)
Object.preventExtensions(...) 禁止一个对象添加新属性，但是可以修改已有属性值 或者 删除已有属性

- 密封(seal)
Object.seal(...) 会创建一个"密封"的对象，这个方法等价于Object.preventExtensions(...)+configurable:false。密封之后不仅不能添加新属性，也不能重新配置或者删除现有属性（可以改属性值）

- 冻结(freeze)
Object.freeze(...) 会创建一个冻结对象，这个方法等价于Object.seal(...)+writable:false,这个方法是对象上的级别最高的不可变性，它会禁止对对象本身及其任意直接属性的修改 深度冻结一个对象

*tips:冻结对象中如果引用了其他对象，也会被冻结*
*Object.freeze(...) 在Vue中可用于大列表的性能优化*
**[[Get]] 获取属性值操作**

对象默认内置[[Get]]操作，该操作首先在对象中查找是否有名称相同的属性，有则返回属性值。没有会返回undefined

**[[Put]] 属性赋值操作**
1. 对象已存在这个属性
    - 属性是否是访问描述符？如果是存在setter则调用setter
    - 属性数据描述中 writable 是否是false,是非严格失败 、严格TypeError
    - 如果都不是，该值设置为属性的值
2. 对象中不存在这个属性 
    TODO 待补充...


**Getter 和 Setter**
对象默认的[[Put]] 和 [[Get]] 操作分别可以控制属性值的 设置和获取 
ES5中 getter 和 setter 可以 改写默认操作

当一个属性定义了 getter 或setter 描述符 这个属性就被定义为"访问描述符"，没有getter 或 setter 的被称为 "数据描述符"。

*访问描述符 会忽略 value 和 wirtable,关注 getter 、setter 、configurable 、enumerable*

**存在性**
判断对象中是否存在该属性
1. in 操作符：会检查是否在对象及 [[Prototype]] 链
2. hasOwnProperty：只会检查属性是否在对象中，不会检查 [[Prototype]] 链
3. 枚举：enumerable 
for ... in 遍历对象时 ，只会遍历可枚举的属性(包括 [[Prototype]] 链) 
*tips: 建议遍历数组使用for 循环，且只在遍历对象上应用 for...in*

```js
for (var k in obj){
    console.log(k,obj[k])
}
```

for...in 遍历对象时无法直接获取属性值，需要手动获取属性值 

ES6新增 ```for...of```用于遍历可迭代对象（Array、Map 、Set 、String、arguments ...）

*for...of 循环首先会向访问对象请求一个迭代器对象，然后通过调用迭代器对象的next()方法来遍历返回所以值*

rray、Map 、Set 、String、arguments 这些可迭代对象都内置了@@iterator
 
```js
// 手动遍历
var myArray=[1,2,3,4]
var it=myArray[Symbol.iterator]()
it.next();//{value:1,done:false}
it.next();//{value:2,done:false}
it.next();//{value:3,done:false}
it.next();//{done:true}
```

# 相关知识点
[Iterator](/2021/05/13/js/es6/iterator/)
