---
title: 树
tags: ['数据结构']
toc: true
date: 2021-05-11 13:20:01
categories: 算法
---
- **前端工作中常见的树：DOM树、级联选择、树形控件...**
- **js中没有树，但是可以使用Object 和 Array 构建树**
- **树的常用操作：深度/广度 优先遍历、前中后序遍历**

### 深度优先遍历
深度优先遍历，尽可能深的搜索树的分支
1. 访问根节点
2. 对根节点children 挨个进行深度优先遍历
```js
const tree={
    val:'a',
    children:[{
        val:'b',
        children:[{
            val:'d',
            children:[]
        },{
            val:'e',
            children:[]
        }]
    },
    {
        val:'c',
        children:[{
            val:'f',
            children:[]
        },{
            val:'g',
            children:[]
        }]
    }]
}
//dfs:deep first search
const dfs=(root)=>{
    console.log(root.val)
    root.children.forEach(dfs)
}
```

### 广度优先遍历
广度优先遍历，先访问离根节点最近的节点
1. 新建一个队列，把根节点入队
2. 把队头出队，并访问
3. 把对头的children 挨个入队
4. 重复上面 2、3步骤知道队列为空

```js
// bfs: breadth first search
const bfs=(root)=>{
    let queue=[root];
    while(queue.length){
        const n=queue.shift();
        console.log(n.val);
        n.children.forEach(child=>{
            queue.push(child)
        })
    }
}
bfs(tree)
```

# 二叉树
- 树中每个节点最多只能有两个子节点
- 在js中用Object 来模拟二叉树

```js
// bt:binary tree
const bt={
    val:1,
    left:{
        val:4,
        left:{
            val:2,
            left:null,
            right:null
        },
        right:{
            val:5,
            left:null,
            right:null
        }
    },
    right:{
        val:3,
        left:{
            val:6,
            left:null,
            right:null
        },
        right:{
            val:7,
            left:null,
            right:null
        }
    }
}
```
### 二叉树的先序遍历算法口诀
1. 访问根节点
2. 访问根节点的左子树进行先序遍历  
3. 访问根节点的右子树进行先序遍历  

```js
//  递归版
const preorder=(root)=>{
    if(!root) return
    console.log(root.val);
    preorder(root.left);
    preorder(root.right);

}
// 非递归版：
const preorder=(root)=>{
    if(!root) return
    let stack=[root];
    while(stack.length){
        const n=stack.pop()
        console.log(n.val)
        if(n.right) stack.push(n.right)
        if(n.left) stack.push(n.left)
    }
}
```

### 二叉树的中序遍历算法口诀
1. 访问根节点的左子树进行中序遍历
2. 访问根节点
3. 对根节点的右子树进行中序遍历

```js
// 递归版本
const inorder=(root)=>{
    if(!root)return 
    inorder(root.left);
    console.log(root.val);
    inorder(root.right)
}
inorder(bt)

// 非递归版:将根节点所有左子树加入栈中,弹出栈顶原数并访问val,将指针指向右子树，右子树作为下一次循环的根节点
const inorder=(root)=>{
     if(!root)return 
     const stack=[];
     let p=root;
     while (stack.length || p){
        while(p){
            stack.push(p)
            p=p.left
        }
        const n=stack.pop();
        console.log(n.val);
        p=n.right
     }
}
```
### 二叉树的后序遍历算法口诀
1. 对根节点的左子树进行后序遍历  
2. 对根节点的右子树进行后续遍历  
3. 访问根节点

```js
// 递归版本
const postorder=(root)=>{
    if(!root)return
    postorder(root.left)
    postorder(root.right)
    console.log(root.val)
}
// 非递归版:和前序遍历类似，然后输出顺序颠倒
const postorder=(root)=>{
    if(!root) return
    const stack=[root];
    const outputstack=[];
    while(stack.length){
        const n=stack.pop();
        outputstack.push(n)
        if(n.left) stack.push(n.left)
        if(n.right) stack.push(n.right)
    }
    while(outputstack.length){
        const n=outputstack.pop()
        console.log(n.val)
    }
}
```


### 题目自测

1. 找到dom树的最深节点(可能多个)，并返回

```js
function findDomDeepChild(node){
    if(!node.children || node.children.length===0){
        return 1
    }
    const max
   
    
}
const root=document.querySelector('body')
findDomDeepChild(root)
```